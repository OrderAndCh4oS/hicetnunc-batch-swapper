# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
  query: query_root
  subscription: subscription_root
}

"whether this query should be cached (Hasura Cloud only)"
directive @cached(
  "refresh the cache entry"
  refresh: Boolean! = false
  "measured in seconds"
  ttl: Int! = 60
) on QUERY

"columns and relationships of \"hic_et_nunc.ask\""
type hic_et_nunc_ask {
  amount: bigint!
  amount_left: bigint!
  "An object relationship"
  artist: holder!
  artist_id: String!
  "An object relationship"
  creator: holder!
  creator_id: String!
  "An object relationship"
  fa2: fa2!
  fa2_id: String!
  "An array relationship"
  fulfilled(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_fulfilled_ask_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_fulfilled_ask_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_fulfilled_ask_bool_exp
  ): [hic_et_nunc_fulfilled_ask!]!
  "An aggregate relationship"
  fulfilled_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_fulfilled_ask_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_fulfilled_ask_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_fulfilled_ask_bool_exp
  ): hic_et_nunc_fulfilled_ask_aggregate!
  id: bigint!
  level: bigint!
  objkt_id: bigint!
  price: bigint!
  royalties: bigint!
  "ACTIVE: active\\nCANCELLED: cancelled\\nCONCLUDED: concluded"
  status: String!
  timestamp: timestamptz!
  update_level: bigint
  update_timestamp: timestamptz
}

"aggregated selection of \"hic_et_nunc.ask\""
type hic_et_nunc_ask_aggregate {
  aggregate: hic_et_nunc_ask_aggregate_fields
  nodes: [hic_et_nunc_ask!]!
}

"aggregate fields of \"hic_et_nunc.ask\""
type hic_et_nunc_ask_aggregate_fields {
  avg: hic_et_nunc_ask_avg_fields
  count(columns: [hic_et_nunc_ask_select_column!], distinct: Boolean): Int!
  max: hic_et_nunc_ask_max_fields
  min: hic_et_nunc_ask_min_fields
  stddev: hic_et_nunc_ask_stddev_fields
  stddev_pop: hic_et_nunc_ask_stddev_pop_fields
  stddev_samp: hic_et_nunc_ask_stddev_samp_fields
  sum: hic_et_nunc_ask_sum_fields
  var_pop: hic_et_nunc_ask_var_pop_fields
  var_samp: hic_et_nunc_ask_var_samp_fields
  variance: hic_et_nunc_ask_variance_fields
}

"aggregate avg on columns"
type hic_et_nunc_ask_avg_fields {
  amount: Float
  amount_left: Float
  id: Float
  level: Float
  objkt_id: Float
  price: Float
  royalties: Float
  update_level: Float
}

"aggregate max on columns"
type hic_et_nunc_ask_max_fields {
  amount: bigint
  amount_left: bigint
  artist_id: String
  creator_id: String
  fa2_id: String
  id: bigint
  level: bigint
  objkt_id: bigint
  price: bigint
  royalties: bigint
  "ACTIVE: active\\nCANCELLED: cancelled\\nCONCLUDED: concluded"
  status: String
  timestamp: timestamptz
  update_level: bigint
  update_timestamp: timestamptz
}

"aggregate min on columns"
type hic_et_nunc_ask_min_fields {
  amount: bigint
  amount_left: bigint
  artist_id: String
  creator_id: String
  fa2_id: String
  id: bigint
  level: bigint
  objkt_id: bigint
  price: bigint
  royalties: bigint
  "ACTIVE: active\\nCANCELLED: cancelled\\nCONCLUDED: concluded"
  status: String
  timestamp: timestamptz
  update_level: bigint
  update_timestamp: timestamptz
}

"aggregate stddev on columns"
type hic_et_nunc_ask_stddev_fields {
  amount: Float
  amount_left: Float
  id: Float
  level: Float
  objkt_id: Float
  price: Float
  royalties: Float
  update_level: Float
}

"aggregate stddev_pop on columns"
type hic_et_nunc_ask_stddev_pop_fields {
  amount: Float
  amount_left: Float
  id: Float
  level: Float
  objkt_id: Float
  price: Float
  royalties: Float
  update_level: Float
}

"aggregate stddev_samp on columns"
type hic_et_nunc_ask_stddev_samp_fields {
  amount: Float
  amount_left: Float
  id: Float
  level: Float
  objkt_id: Float
  price: Float
  royalties: Float
  update_level: Float
}

"aggregate sum on columns"
type hic_et_nunc_ask_sum_fields {
  amount: bigint
  amount_left: bigint
  id: bigint
  level: bigint
  objkt_id: bigint
  price: bigint
  royalties: bigint
  update_level: bigint
}

"aggregate var_pop on columns"
type hic_et_nunc_ask_var_pop_fields {
  amount: Float
  amount_left: Float
  id: Float
  level: Float
  objkt_id: Float
  price: Float
  royalties: Float
  update_level: Float
}

"aggregate var_samp on columns"
type hic_et_nunc_ask_var_samp_fields {
  amount: Float
  amount_left: Float
  id: Float
  level: Float
  objkt_id: Float
  price: Float
  royalties: Float
  update_level: Float
}

"aggregate variance on columns"
type hic_et_nunc_ask_variance_fields {
  amount: Float
  amount_left: Float
  id: Float
  level: Float
  objkt_id: Float
  price: Float
  royalties: Float
  update_level: Float
}

"columns and relationships of \"hic_et_nunc.bid\""
type hic_et_nunc_bid {
  "An object relationship"
  artist: holder!
  artist_id: String!
  "An object relationship"
  creator: holder!
  creator_id: String!
  "An object relationship"
  fa2: fa2!
  fa2_id: String!
  id: bigint!
  level: bigint!
  objkt_id: bigint!
  price: bigint!
  royalties: bigint!
  "An object relationship"
  seller: holder
  seller_id: String
  "ACTIVE: active\\nCANCELLED: cancelled\\nCONCLUDED: concluded"
  status: String!
  timestamp: timestamptz!
  update_level: bigint
  update_timestamp: timestamptz
}

"aggregated selection of \"hic_et_nunc.bid\""
type hic_et_nunc_bid_aggregate {
  aggregate: hic_et_nunc_bid_aggregate_fields
  nodes: [hic_et_nunc_bid!]!
}

"aggregate fields of \"hic_et_nunc.bid\""
type hic_et_nunc_bid_aggregate_fields {
  avg: hic_et_nunc_bid_avg_fields
  count(columns: [hic_et_nunc_bid_select_column!], distinct: Boolean): Int!
  max: hic_et_nunc_bid_max_fields
  min: hic_et_nunc_bid_min_fields
  stddev: hic_et_nunc_bid_stddev_fields
  stddev_pop: hic_et_nunc_bid_stddev_pop_fields
  stddev_samp: hic_et_nunc_bid_stddev_samp_fields
  sum: hic_et_nunc_bid_sum_fields
  var_pop: hic_et_nunc_bid_var_pop_fields
  var_samp: hic_et_nunc_bid_var_samp_fields
  variance: hic_et_nunc_bid_variance_fields
}

"aggregate avg on columns"
type hic_et_nunc_bid_avg_fields {
  id: Float
  level: Float
  objkt_id: Float
  price: Float
  royalties: Float
  update_level: Float
}

"aggregate max on columns"
type hic_et_nunc_bid_max_fields {
  artist_id: String
  creator_id: String
  fa2_id: String
  id: bigint
  level: bigint
  objkt_id: bigint
  price: bigint
  royalties: bigint
  seller_id: String
  "ACTIVE: active\\nCANCELLED: cancelled\\nCONCLUDED: concluded"
  status: String
  timestamp: timestamptz
  update_level: bigint
  update_timestamp: timestamptz
}

"aggregate min on columns"
type hic_et_nunc_bid_min_fields {
  artist_id: String
  creator_id: String
  fa2_id: String
  id: bigint
  level: bigint
  objkt_id: bigint
  price: bigint
  royalties: bigint
  seller_id: String
  "ACTIVE: active\\nCANCELLED: cancelled\\nCONCLUDED: concluded"
  status: String
  timestamp: timestamptz
  update_level: bigint
  update_timestamp: timestamptz
}

"aggregate stddev on columns"
type hic_et_nunc_bid_stddev_fields {
  id: Float
  level: Float
  objkt_id: Float
  price: Float
  royalties: Float
  update_level: Float
}

"aggregate stddev_pop on columns"
type hic_et_nunc_bid_stddev_pop_fields {
  id: Float
  level: Float
  objkt_id: Float
  price: Float
  royalties: Float
  update_level: Float
}

"aggregate stddev_samp on columns"
type hic_et_nunc_bid_stddev_samp_fields {
  id: Float
  level: Float
  objkt_id: Float
  price: Float
  royalties: Float
  update_level: Float
}

"aggregate sum on columns"
type hic_et_nunc_bid_sum_fields {
  id: bigint
  level: bigint
  objkt_id: bigint
  price: bigint
  royalties: bigint
  update_level: bigint
}

"aggregate var_pop on columns"
type hic_et_nunc_bid_var_pop_fields {
  id: Float
  level: Float
  objkt_id: Float
  price: Float
  royalties: Float
  update_level: Float
}

"aggregate var_samp on columns"
type hic_et_nunc_bid_var_samp_fields {
  id: Float
  level: Float
  objkt_id: Float
  price: Float
  royalties: Float
  update_level: Float
}

"aggregate variance on columns"
type hic_et_nunc_bid_variance_fields {
  id: Float
  level: Float
  objkt_id: Float
  price: Float
  royalties: Float
  update_level: Float
}

"Stores current level of index and hash of it's config"
type dipdup_index {
  hash: String
  index_hash: String!
  index_name: String!
  "operation: operation\\nbig_map: big_map\\nblock: block\\nschema: schema"
  index_type: String!
  level: Int!
}

"aggregated selection of \"hic_et_nunc.dipdup_state\""
type dipdup_index_aggregate {
  aggregate: dipdup_index_aggregate_fields
  nodes: [dipdup_index!]!
}

"aggregate fields of \"hic_et_nunc.dipdup_state\""
type dipdup_index_aggregate_fields {
  avg: dipdup_index_avg_fields
  count(columns: [dipdup_index_select_column!], distinct: Boolean): Int!
  max: dipdup_index_max_fields
  min: dipdup_index_min_fields
  stddev: dipdup_index_stddev_fields
  stddev_pop: dipdup_index_stddev_pop_fields
  stddev_samp: dipdup_index_stddev_samp_fields
  sum: dipdup_index_sum_fields
  var_pop: dipdup_index_var_pop_fields
  var_samp: dipdup_index_var_samp_fields
  variance: dipdup_index_variance_fields
}

"aggregate avg on columns"
type dipdup_index_avg_fields {
  level: Float
}

"aggregate max on columns"
type dipdup_index_max_fields {
  hash: String
  index_hash: String
  index_name: String
  "operation: operation\\nbig_map: big_map\\nblock: block\\nschema: schema"
  index_type: String
  level: Int
}

"aggregate min on columns"
type dipdup_index_min_fields {
  hash: String
  index_hash: String
  index_name: String
  "operation: operation\\nbig_map: big_map\\nblock: block\\nschema: schema"
  index_type: String
  level: Int
}

"aggregate stddev on columns"
type dipdup_index_stddev_fields {
  level: Float
}

"aggregate stddev_pop on columns"
type dipdup_index_stddev_pop_fields {
  level: Float
}

"aggregate stddev_samp on columns"
type dipdup_index_stddev_samp_fields {
  level: Float
}

"aggregate sum on columns"
type dipdup_index_sum_fields {
  level: Int
}

"aggregate var_pop on columns"
type dipdup_index_var_pop_fields {
  level: Float
}

"aggregate var_samp on columns"
type dipdup_index_var_samp_fields {
  level: Float
}

"aggregate variance on columns"
type dipdup_index_variance_fields {
  level: Float
}

"columns and relationships of \"hic_et_nunc.dutch_auction\""
type hic_et_nunc_dutch_auction {
  "An object relationship"
  artist: holder!
  artist_id: String!
  buy_price: bigint
  "An object relationship"
  buyer: holder
  buyer_id: String
  contract_version: smallint!
  "An object relationship"
  creator: holder!
  creator_id: String!
  end_price: bigint!
  end_time: timestamptz!
  "An object relationship"
  fa2: fa2!
  fa2_id: String!
  hash: String!
  id: bigint!
  level: bigint!
  objkt_id: bigint!
  royalties: bigint!
  start_price: bigint!
  start_time: timestamptz!
  "ACTIVE: active\\nCANCELLED: cancelled\\nCONCLUDED: concluded"
  status: String!
  timestamp: timestamptz!
  update_level: bigint
  update_timestamp: timestamptz
}

"aggregated selection of \"hic_et_nunc.dutch_auction\""
type hic_et_nunc_dutch_auction_aggregate {
  aggregate: hic_et_nunc_dutch_auction_aggregate_fields
  nodes: [hic_et_nunc_dutch_auction!]!
}

"aggregate fields of \"hic_et_nunc.dutch_auction\""
type hic_et_nunc_dutch_auction_aggregate_fields {
  avg: hic_et_nunc_dutch_auction_avg_fields
  count(
    columns: [hic_et_nunc_dutch_auction_select_column!]
    distinct: Boolean
  ): Int!
  max: hic_et_nunc_dutch_auction_max_fields
  min: hic_et_nunc_dutch_auction_min_fields
  stddev: hic_et_nunc_dutch_auction_stddev_fields
  stddev_pop: hic_et_nunc_dutch_auction_stddev_pop_fields
  stddev_samp: hic_et_nunc_dutch_auction_stddev_samp_fields
  sum: hic_et_nunc_dutch_auction_sum_fields
  var_pop: hic_et_nunc_dutch_auction_var_pop_fields
  var_samp: hic_et_nunc_dutch_auction_var_samp_fields
  variance: hic_et_nunc_dutch_auction_variance_fields
}

"aggregate avg on columns"
type hic_et_nunc_dutch_auction_avg_fields {
  buy_price: Float
  contract_version: Float
  end_price: Float
  id: Float
  level: Float
  objkt_id: Float
  royalties: Float
  start_price: Float
  update_level: Float
}

"aggregate max on columns"
type hic_et_nunc_dutch_auction_max_fields {
  artist_id: String
  buy_price: bigint
  buyer_id: String
  contract_version: smallint
  creator_id: String
  end_price: bigint
  end_time: timestamptz
  fa2_id: String
  hash: String
  id: bigint
  level: bigint
  objkt_id: bigint
  royalties: bigint
  start_price: bigint
  start_time: timestamptz
  "ACTIVE: active\\nCANCELLED: cancelled\\nCONCLUDED: concluded"
  status: String
  timestamp: timestamptz
  update_level: bigint
  update_timestamp: timestamptz
}

"aggregate min on columns"
type hic_et_nunc_dutch_auction_min_fields {
  artist_id: String
  buy_price: bigint
  buyer_id: String
  contract_version: smallint
  creator_id: String
  end_price: bigint
  end_time: timestamptz
  fa2_id: String
  hash: String
  id: bigint
  level: bigint
  objkt_id: bigint
  royalties: bigint
  start_price: bigint
  start_time: timestamptz
  "ACTIVE: active\\nCANCELLED: cancelled\\nCONCLUDED: concluded"
  status: String
  timestamp: timestamptz
  update_level: bigint
  update_timestamp: timestamptz
}

"aggregate stddev on columns"
type hic_et_nunc_dutch_auction_stddev_fields {
  buy_price: Float
  contract_version: Float
  end_price: Float
  id: Float
  level: Float
  objkt_id: Float
  royalties: Float
  start_price: Float
  update_level: Float
}

"aggregate stddev_pop on columns"
type hic_et_nunc_dutch_auction_stddev_pop_fields {
  buy_price: Float
  contract_version: Float
  end_price: Float
  id: Float
  level: Float
  objkt_id: Float
  royalties: Float
  start_price: Float
  update_level: Float
}

"aggregate stddev_samp on columns"
type hic_et_nunc_dutch_auction_stddev_samp_fields {
  buy_price: Float
  contract_version: Float
  end_price: Float
  id: Float
  level: Float
  objkt_id: Float
  royalties: Float
  start_price: Float
  update_level: Float
}

"aggregate sum on columns"
type hic_et_nunc_dutch_auction_sum_fields {
  buy_price: bigint
  contract_version: smallint
  end_price: bigint
  id: bigint
  level: bigint
  objkt_id: bigint
  royalties: bigint
  start_price: bigint
  update_level: bigint
}

"aggregate var_pop on columns"
type hic_et_nunc_dutch_auction_var_pop_fields {
  buy_price: Float
  contract_version: Float
  end_price: Float
  id: Float
  level: Float
  objkt_id: Float
  royalties: Float
  start_price: Float
  update_level: Float
}

"aggregate var_samp on columns"
type hic_et_nunc_dutch_auction_var_samp_fields {
  buy_price: Float
  contract_version: Float
  end_price: Float
  id: Float
  level: Float
  objkt_id: Float
  royalties: Float
  start_price: Float
  update_level: Float
}

"aggregate variance on columns"
type hic_et_nunc_dutch_auction_variance_fields {
  buy_price: Float
  contract_version: Float
  end_price: Float
  id: Float
  level: Float
  objkt_id: Float
  royalties: Float
  start_price: Float
  update_level: Float
}

"columns and relationships of \"hic_et_nunc.english_auction\""
type hic_et_nunc_english_auction {
  "An object relationship"
  artist: holder!
  artist_id: String!
  "An array relationship"
  bids(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_english_bid_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_english_bid_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_english_bid_bool_exp
  ): [hic_et_nunc_english_bid!]!
  "An aggregate relationship"
  bids_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_english_bid_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_english_bid_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_english_bid_bool_exp
  ): hic_et_nunc_english_bid_aggregate!
  contract_version: smallint!
  "An object relationship"
  creator: holder!
  creator_id: String!
  end_time: timestamptz!
  extension_time: bigint!
  "An object relationship"
  fa2: fa2!
  fa2_id: String!
  hash: String!
  id: bigint!
  level: bigint!
  objkt_id: bigint!
  price_increment: bigint!
  reserve: bigint!
  royalties: bigint!
  start_time: timestamptz!
  "ACTIVE: active\\nCANCELLED: cancelled\\nCONCLUDED: concluded"
  status: String!
  timestamp: timestamptz!
  update_level: bigint
  update_timestamp: timestamptz
}

"aggregated selection of \"hic_et_nunc.english_auction\""
type hic_et_nunc_english_auction_aggregate {
  aggregate: hic_et_nunc_english_auction_aggregate_fields
  nodes: [hic_et_nunc_english_auction!]!
}

"aggregate fields of \"hic_et_nunc.english_auction\""
type hic_et_nunc_english_auction_aggregate_fields {
  avg: hic_et_nunc_english_auction_avg_fields
  count(
    columns: [hic_et_nunc_english_auction_select_column!]
    distinct: Boolean
  ): Int!
  max: hic_et_nunc_english_auction_max_fields
  min: hic_et_nunc_english_auction_min_fields
  stddev: hic_et_nunc_english_auction_stddev_fields
  stddev_pop: hic_et_nunc_english_auction_stddev_pop_fields
  stddev_samp: hic_et_nunc_english_auction_stddev_samp_fields
  sum: hic_et_nunc_english_auction_sum_fields
  var_pop: hic_et_nunc_english_auction_var_pop_fields
  var_samp: hic_et_nunc_english_auction_var_samp_fields
  variance: hic_et_nunc_english_auction_variance_fields
}

"aggregate avg on columns"
type hic_et_nunc_english_auction_avg_fields {
  contract_version: Float
  extension_time: Float
  id: Float
  level: Float
  objkt_id: Float
  price_increment: Float
  reserve: Float
  royalties: Float
  update_level: Float
}

"aggregate max on columns"
type hic_et_nunc_english_auction_max_fields {
  artist_id: String
  contract_version: smallint
  creator_id: String
  end_time: timestamptz
  extension_time: bigint
  fa2_id: String
  hash: String
  id: bigint
  level: bigint
  objkt_id: bigint
  price_increment: bigint
  reserve: bigint
  royalties: bigint
  start_time: timestamptz
  "ACTIVE: active\\nCANCELLED: cancelled\\nCONCLUDED: concluded"
  status: String
  timestamp: timestamptz
  update_level: bigint
  update_timestamp: timestamptz
}

"aggregate min on columns"
type hic_et_nunc_english_auction_min_fields {
  artist_id: String
  contract_version: smallint
  creator_id: String
  end_time: timestamptz
  extension_time: bigint
  fa2_id: String
  hash: String
  id: bigint
  level: bigint
  objkt_id: bigint
  price_increment: bigint
  reserve: bigint
  royalties: bigint
  start_time: timestamptz
  "ACTIVE: active\\nCANCELLED: cancelled\\nCONCLUDED: concluded"
  status: String
  timestamp: timestamptz
  update_level: bigint
  update_timestamp: timestamptz
}

"aggregate stddev on columns"
type hic_et_nunc_english_auction_stddev_fields {
  contract_version: Float
  extension_time: Float
  id: Float
  level: Float
  objkt_id: Float
  price_increment: Float
  reserve: Float
  royalties: Float
  update_level: Float
}

"aggregate stddev_pop on columns"
type hic_et_nunc_english_auction_stddev_pop_fields {
  contract_version: Float
  extension_time: Float
  id: Float
  level: Float
  objkt_id: Float
  price_increment: Float
  reserve: Float
  royalties: Float
  update_level: Float
}

"aggregate stddev_samp on columns"
type hic_et_nunc_english_auction_stddev_samp_fields {
  contract_version: Float
  extension_time: Float
  id: Float
  level: Float
  objkt_id: Float
  price_increment: Float
  reserve: Float
  royalties: Float
  update_level: Float
}

"aggregate sum on columns"
type hic_et_nunc_english_auction_sum_fields {
  contract_version: smallint
  extension_time: bigint
  id: bigint
  level: bigint
  objkt_id: bigint
  price_increment: bigint
  reserve: bigint
  royalties: bigint
  update_level: bigint
}

"aggregate var_pop on columns"
type hic_et_nunc_english_auction_var_pop_fields {
  contract_version: Float
  extension_time: Float
  id: Float
  level: Float
  objkt_id: Float
  price_increment: Float
  reserve: Float
  royalties: Float
  update_level: Float
}

"aggregate var_samp on columns"
type hic_et_nunc_english_auction_var_samp_fields {
  contract_version: Float
  extension_time: Float
  id: Float
  level: Float
  objkt_id: Float
  price_increment: Float
  reserve: Float
  royalties: Float
  update_level: Float
}

"aggregate variance on columns"
type hic_et_nunc_english_auction_variance_fields {
  contract_version: Float
  extension_time: Float
  id: Float
  level: Float
  objkt_id: Float
  price_increment: Float
  reserve: Float
  royalties: Float
  update_level: Float
}

"columns and relationships of \"hic_et_nunc.english_bid\""
type hic_et_nunc_english_bid {
  amount: bigint!
  "An object relationship"
  auction: hic_et_nunc_english_auction!
  auction_id: bigint!
  "An object relationship"
  bidder: holder!
  bidder_id: String!
  id: bigint!
  level: bigint!
  timestamp: timestamptz!
}

"aggregated selection of \"hic_et_nunc.english_bid\""
type hic_et_nunc_english_bid_aggregate {
  aggregate: hic_et_nunc_english_bid_aggregate_fields
  nodes: [hic_et_nunc_english_bid!]!
}

"aggregate fields of \"hic_et_nunc.english_bid\""
type hic_et_nunc_english_bid_aggregate_fields {
  avg: hic_et_nunc_english_bid_avg_fields
  count(
    columns: [hic_et_nunc_english_bid_select_column!]
    distinct: Boolean
  ): Int!
  max: hic_et_nunc_english_bid_max_fields
  min: hic_et_nunc_english_bid_min_fields
  stddev: hic_et_nunc_english_bid_stddev_fields
  stddev_pop: hic_et_nunc_english_bid_stddev_pop_fields
  stddev_samp: hic_et_nunc_english_bid_stddev_samp_fields
  sum: hic_et_nunc_english_bid_sum_fields
  var_pop: hic_et_nunc_english_bid_var_pop_fields
  var_samp: hic_et_nunc_english_bid_var_samp_fields
  variance: hic_et_nunc_english_bid_variance_fields
}

"aggregate avg on columns"
type hic_et_nunc_english_bid_avg_fields {
  amount: Float
  auction_id: Float
  id: Float
  level: Float
}

"aggregate max on columns"
type hic_et_nunc_english_bid_max_fields {
  amount: bigint
  auction_id: bigint
  bidder_id: String
  id: bigint
  level: bigint
  timestamp: timestamptz
}

"aggregate min on columns"
type hic_et_nunc_english_bid_min_fields {
  amount: bigint
  auction_id: bigint
  bidder_id: String
  id: bigint
  level: bigint
  timestamp: timestamptz
}

"aggregate stddev on columns"
type hic_et_nunc_english_bid_stddev_fields {
  amount: Float
  auction_id: Float
  id: Float
  level: Float
}

"aggregate stddev_pop on columns"
type hic_et_nunc_english_bid_stddev_pop_fields {
  amount: Float
  auction_id: Float
  id: Float
  level: Float
}

"aggregate stddev_samp on columns"
type hic_et_nunc_english_bid_stddev_samp_fields {
  amount: Float
  auction_id: Float
  id: Float
  level: Float
}

"aggregate sum on columns"
type hic_et_nunc_english_bid_sum_fields {
  amount: bigint
  auction_id: bigint
  id: bigint
  level: bigint
}

"aggregate var_pop on columns"
type hic_et_nunc_english_bid_var_pop_fields {
  amount: Float
  auction_id: Float
  id: Float
  level: Float
}

"aggregate var_samp on columns"
type hic_et_nunc_english_bid_var_samp_fields {
  amount: Float
  auction_id: Float
  id: Float
  level: Float
}

"aggregate variance on columns"
type hic_et_nunc_english_bid_variance_fields {
  amount: Float
  auction_id: Float
  id: Float
  level: Float
}

"columns and relationships of \"hic_et_nunc.fa2\""
type fa2 {
  "An array relationship"
  asks(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_ask_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_ask_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_ask_bool_exp
  ): [hic_et_nunc_ask!]!
  "An aggregate relationship"
  asks_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_ask_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_ask_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_ask_bool_exp
  ): hic_et_nunc_ask_aggregate!
  "An array relationship"
  bids(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_bid_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_bid_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_bid_bool_exp
  ): [hic_et_nunc_bid!]!
  "An aggregate relationship"
  bids_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_bid_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_bid_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_bid_bool_exp
  ): hic_et_nunc_bid_aggregate!
  contract: String!
  "An array relationship"
  dutch_auctions(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_dutch_auction_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_dutch_auction_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_dutch_auction_bool_exp
  ): [hic_et_nunc_dutch_auction!]!
  "An aggregate relationship"
  dutch_auctions_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_dutch_auction_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_dutch_auction_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_dutch_auction_bool_exp
  ): hic_et_nunc_dutch_auction_aggregate!
  "An array relationship"
  english_auctions(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_english_auction_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_english_auction_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_english_auction_bool_exp
  ): [hic_et_nunc_english_auction!]!
  "An aggregate relationship"
  english_auctions_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_english_auction_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_english_auction_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_english_auction_bool_exp
  ): hic_et_nunc_english_auction_aggregate!
  "An array relationship"
  swaps(
    "distinct select on columns"
    distinct_on: [swap_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [swap_order_by!]
    "filter the rows returned"
    where: swap_bool_exp
  ): [swap!]!
  "An aggregate relationship"
  swaps_aggregate(
    "distinct select on columns"
    distinct_on: [swap_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [swap_order_by!]
    "filter the rows returned"
    where: swap_bool_exp
  ): swap_aggregate!
}

"aggregated selection of \"hic_et_nunc.fa2\""
type fa2_aggregate {
  aggregate: fa2_aggregate_fields
  nodes: [fa2!]!
}

"aggregate fields of \"hic_et_nunc.fa2\""
type fa2_aggregate_fields {
  count(columns: [fa2_select_column!], distinct: Boolean): Int!
  max: fa2_max_fields
  min: fa2_min_fields
}

"aggregate max on columns"
type fa2_max_fields {
  contract: String
}

"aggregate min on columns"
type fa2_min_fields {
  contract: String
}

"columns and relationships of \"hic_et_nunc.fulfilled_ask\""
type hic_et_nunc_fulfilled_ask {
  amount: bigint!
  "An object relationship"
  ask: hic_et_nunc_ask!
  ask_id: bigint!
  "An object relationship"
  buyer: holder!
  buyer_id: String!
  id: bigint!
  level: bigint!
  objkt_id: bigint!
  "An object relationship"
  seller: holder!
  seller_id: String!
  timestamp: timestamptz!
}

"aggregated selection of \"hic_et_nunc.fulfilled_ask\""
type hic_et_nunc_fulfilled_ask_aggregate {
  aggregate: hic_et_nunc_fulfilled_ask_aggregate_fields
  nodes: [hic_et_nunc_fulfilled_ask!]!
}

"aggregate fields of \"hic_et_nunc.fulfilled_ask\""
type hic_et_nunc_fulfilled_ask_aggregate_fields {
  avg: hic_et_nunc_fulfilled_ask_avg_fields
  count(
    columns: [hic_et_nunc_fulfilled_ask_select_column!]
    distinct: Boolean
  ): Int!
  max: hic_et_nunc_fulfilled_ask_max_fields
  min: hic_et_nunc_fulfilled_ask_min_fields
  stddev: hic_et_nunc_fulfilled_ask_stddev_fields
  stddev_pop: hic_et_nunc_fulfilled_ask_stddev_pop_fields
  stddev_samp: hic_et_nunc_fulfilled_ask_stddev_samp_fields
  sum: hic_et_nunc_fulfilled_ask_sum_fields
  var_pop: hic_et_nunc_fulfilled_ask_var_pop_fields
  var_samp: hic_et_nunc_fulfilled_ask_var_samp_fields
  variance: hic_et_nunc_fulfilled_ask_variance_fields
}

"aggregate avg on columns"
type hic_et_nunc_fulfilled_ask_avg_fields {
  amount: Float
  ask_id: Float
  id: Float
  level: Float
  objkt_id: Float
}

"aggregate max on columns"
type hic_et_nunc_fulfilled_ask_max_fields {
  amount: bigint
  ask_id: bigint
  buyer_id: String
  id: bigint
  level: bigint
  objkt_id: bigint
  seller_id: String
  timestamp: timestamptz
}

"aggregate min on columns"
type hic_et_nunc_fulfilled_ask_min_fields {
  amount: bigint
  ask_id: bigint
  buyer_id: String
  id: bigint
  level: bigint
  objkt_id: bigint
  seller_id: String
  timestamp: timestamptz
}

"aggregate stddev on columns"
type hic_et_nunc_fulfilled_ask_stddev_fields {
  amount: Float
  ask_id: Float
  id: Float
  level: Float
  objkt_id: Float
}

"aggregate stddev_pop on columns"
type hic_et_nunc_fulfilled_ask_stddev_pop_fields {
  amount: Float
  ask_id: Float
  id: Float
  level: Float
  objkt_id: Float
}

"aggregate stddev_samp on columns"
type hic_et_nunc_fulfilled_ask_stddev_samp_fields {
  amount: Float
  ask_id: Float
  id: Float
  level: Float
  objkt_id: Float
}

"aggregate sum on columns"
type hic_et_nunc_fulfilled_ask_sum_fields {
  amount: bigint
  ask_id: bigint
  id: bigint
  level: bigint
  objkt_id: bigint
}

"aggregate var_pop on columns"
type hic_et_nunc_fulfilled_ask_var_pop_fields {
  amount: Float
  ask_id: Float
  id: Float
  level: Float
  objkt_id: Float
}

"aggregate var_samp on columns"
type hic_et_nunc_fulfilled_ask_var_samp_fields {
  amount: Float
  ask_id: Float
  id: Float
  level: Float
  objkt_id: Float
}

"aggregate variance on columns"
type hic_et_nunc_fulfilled_ask_variance_fields {
  amount: Float
  ask_id: Float
  id: Float
  level: Float
  objkt_id: Float
}

"columns and relationships of \"hic_et_nunc.holder\""
type holder {
  address: String!
  "An array relationship"
  asks(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_ask_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_ask_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_ask_bool_exp
  ): [hic_et_nunc_ask!]!
  "An aggregate relationship"
  asks_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_ask_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_ask_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_ask_bool_exp
  ): hic_et_nunc_ask_aggregate!
  "An array relationship"
  bids(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_bid_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_bid_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_bid_bool_exp
  ): [hic_et_nunc_bid!]!
  "An aggregate relationship"
  bids_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_bid_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_bid_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_bid_bool_exp
  ): hic_et_nunc_bid_aggregate!
  "An array relationship"
  bought_asks(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_fulfilled_ask_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_fulfilled_ask_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_fulfilled_ask_bool_exp
  ): [hic_et_nunc_fulfilled_ask!]!
  "An aggregate relationship"
  bought_asks_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_fulfilled_ask_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_fulfilled_ask_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_fulfilled_ask_bool_exp
  ): hic_et_nunc_fulfilled_ask_aggregate!
  "An array relationship"
  created_dutch_auctions(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_dutch_auction_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_dutch_auction_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_dutch_auction_bool_exp
  ): [hic_et_nunc_dutch_auction!]!
  "An aggregate relationship"
  created_dutch_auctions_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_dutch_auction_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_dutch_auction_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_dutch_auction_bool_exp
  ): hic_et_nunc_dutch_auction_aggregate!
  "An array relationship"
  created_english_auctions(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_english_auction_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_english_auction_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_english_auction_bool_exp
  ): [hic_et_nunc_english_auction!]!
  "An aggregate relationship"
  created_english_auctions_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_english_auction_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_english_auction_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_english_auction_bool_exp
  ): hic_et_nunc_english_auction_aggregate!
  description: String!
  "An array relationship"
  english_bids(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_english_bid_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_english_bid_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_english_bid_bool_exp
  ): [hic_et_nunc_english_bid!]!
  "An aggregate relationship"
  english_bids_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_english_bid_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_english_bid_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_english_bid_bool_exp
  ): hic_et_nunc_english_bid_aggregate!
  hdao_balance: bigint!
  "An array relationship"
  holder_signatures(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_split_signatures_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_split_signatures_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_split_signatures_bool_exp
  ): [hic_et_nunc_split_signatures!]!
  "An aggregate relationship"
  holder_signatures_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_split_signatures_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_split_signatures_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_split_signatures_bool_exp
  ): hic_et_nunc_split_signatures_aggregate!
  "An array relationship"
  holders_token(
    "distinct select on columns"
    distinct_on: [token_holder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_holder_order_by!]
    "filter the rows returned"
    where: token_holder_bool_exp
  ): [token_holder!]!
  "An aggregate relationship"
  holders_token_aggregate(
    "distinct select on columns"
    distinct_on: [token_holder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_holder_order_by!]
    "filter the rows returned"
    where: token_holder_bool_exp
  ): token_holder_aggregate!
  is_split: Boolean!
  metadata("JSON select path" path: String): jsonb!
  metadata_file: String!
  name: String!
  "An array relationship"
  owner(
    "distinct select on columns"
    distinct_on: [token_operator_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_operator_order_by!]
    "filter the rows returned"
    where: token_operator_bool_exp
  ): [token_operator!]!
  "An aggregate relationship"
  owner_aggregate(
    "distinct select on columns"
    distinct_on: [token_operator_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_operator_order_by!]
    "filter the rows returned"
    where: token_operator_bool_exp
  ): token_operator_aggregate!
  "An array relationship"
  purchases(
    "distinct select on columns"
    distinct_on: [trade_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [trade_order_by!]
    "filter the rows returned"
    where: trade_bool_exp
  ): [trade!]!
  "An aggregate relationship"
  purchases_aggregate(
    "distinct select on columns"
    distinct_on: [trade_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [trade_order_by!]
    "filter the rows returned"
    where: trade_bool_exp
  ): trade_aggregate!
  "An array relationship"
  sales(
    "distinct select on columns"
    distinct_on: [trade_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [trade_order_by!]
    "filter the rows returned"
    where: trade_bool_exp
  ): [trade!]!
  "An aggregate relationship"
  sales_aggregate(
    "distinct select on columns"
    distinct_on: [trade_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [trade_order_by!]
    "filter the rows returned"
    where: trade_bool_exp
  ): trade_aggregate!
  "An array relationship"
  shareholder(
    "distinct select on columns"
    distinct_on: [shareholder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [shareholder_order_by!]
    "filter the rows returned"
    where: shareholder_bool_exp
  ): [shareholder!]!
  "An aggregate relationship"
  shareholder_aggregate(
    "distinct select on columns"
    distinct_on: [shareholder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [shareholder_order_by!]
    "filter the rows returned"
    where: shareholder_bool_exp
  ): shareholder_aggregate!
  "An array relationship"
  shares(
    "distinct select on columns"
    distinct_on: [splitcontract_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [splitcontract_order_by!]
    "filter the rows returned"
    where: splitcontract_bool_exp
  ): [splitcontract!]!
  "An aggregate relationship"
  shares_aggregate(
    "distinct select on columns"
    distinct_on: [splitcontract_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [splitcontract_order_by!]
    "filter the rows returned"
    where: splitcontract_bool_exp
  ): splitcontract_aggregate!
  "An array relationship"
  sold_asks(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_fulfilled_ask_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_fulfilled_ask_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_fulfilled_ask_bool_exp
  ): [hic_et_nunc_fulfilled_ask!]!
  "An aggregate relationship"
  sold_asks_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_fulfilled_ask_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_fulfilled_ask_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_fulfilled_ask_bool_exp
  ): hic_et_nunc_fulfilled_ask_aggregate!
  "An array relationship"
  sold_bids(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_bid_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_bid_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_bid_bool_exp
  ): [hic_et_nunc_bid!]!
  "An aggregate relationship"
  sold_bids_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_bid_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_bid_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_bid_bool_exp
  ): hic_et_nunc_bid_aggregate!
  "An array relationship"
  starring_asks(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_ask_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_ask_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_ask_bool_exp
  ): [hic_et_nunc_ask!]!
  "An aggregate relationship"
  starring_asks_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_ask_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_ask_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_ask_bool_exp
  ): hic_et_nunc_ask_aggregate!
  "An array relationship"
  starring_bids(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_bid_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_bid_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_bid_bool_exp
  ): [hic_et_nunc_bid!]!
  "An aggregate relationship"
  starring_bids_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_bid_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_bid_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_bid_bool_exp
  ): hic_et_nunc_bid_aggregate!
  "An array relationship"
  starring_dutch_auctions(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_dutch_auction_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_dutch_auction_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_dutch_auction_bool_exp
  ): [hic_et_nunc_dutch_auction!]!
  "An aggregate relationship"
  starring_dutch_auctions_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_dutch_auction_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_dutch_auction_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_dutch_auction_bool_exp
  ): hic_et_nunc_dutch_auction_aggregate!
  "An array relationship"
  starring_english_auctions(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_english_auction_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_english_auction_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_english_auction_bool_exp
  ): [hic_et_nunc_english_auction!]!
  "An aggregate relationship"
  starring_english_auctions_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_english_auction_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_english_auction_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_english_auction_bool_exp
  ): hic_et_nunc_english_auction_aggregate!
  "An array relationship"
  swaps(
    "distinct select on columns"
    distinct_on: [swap_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [swap_order_by!]
    "filter the rows returned"
    where: swap_bool_exp
  ): [swap!]!
  "An aggregate relationship"
  swaps_aggregate(
    "distinct select on columns"
    distinct_on: [swap_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [swap_order_by!]
    "filter the rows returned"
    where: swap_bool_exp
  ): swap_aggregate!
  "An array relationship"
  tokens(
    "distinct select on columns"
    distinct_on: [token_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_order_by!]
    "filter the rows returned"
    where: token_bool_exp
  ): [token!]!
  "An aggregate relationship"
  tokens_aggregate(
    "distinct select on columns"
    distinct_on: [token_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_order_by!]
    "filter the rows returned"
    where: token_bool_exp
  ): token_aggregate!
  "An array relationship"
  won_dutch_auctions(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_dutch_auction_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_dutch_auction_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_dutch_auction_bool_exp
  ): [hic_et_nunc_dutch_auction!]!
  "An aggregate relationship"
  won_dutch_auctions_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_dutch_auction_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_dutch_auction_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_dutch_auction_bool_exp
  ): hic_et_nunc_dutch_auction_aggregate!
}

"aggregated selection of \"hic_et_nunc.holder\""
type holder_aggregate {
  aggregate: holder_aggregate_fields
  nodes: [holder!]!
}

"aggregate fields of \"hic_et_nunc.holder\""
type holder_aggregate_fields {
  avg: holder_avg_fields
  count(columns: [holder_select_column!], distinct: Boolean): Int!
  max: holder_max_fields
  min: holder_min_fields
  stddev: holder_stddev_fields
  stddev_pop: holder_stddev_pop_fields
  stddev_samp: holder_stddev_samp_fields
  sum: holder_sum_fields
  var_pop: holder_var_pop_fields
  var_samp: holder_var_samp_fields
  variance: holder_variance_fields
}

"aggregate avg on columns"
type holder_avg_fields {
  hdao_balance: Float
}

"aggregate max on columns"
type holder_max_fields {
  address: String
  description: String
  hdao_balance: bigint
  metadata_file: String
  name: String
}

"aggregate min on columns"
type holder_min_fields {
  address: String
  description: String
  hdao_balance: bigint
  metadata_file: String
  name: String
}

"aggregate stddev on columns"
type holder_stddev_fields {
  hdao_balance: Float
}

"aggregate stddev_pop on columns"
type holder_stddev_pop_fields {
  hdao_balance: Float
}

"aggregate stddev_samp on columns"
type holder_stddev_samp_fields {
  hdao_balance: Float
}

"aggregate sum on columns"
type holder_sum_fields {
  hdao_balance: bigint
}

"aggregate var_pop on columns"
type holder_var_pop_fields {
  hdao_balance: Float
}

"aggregate var_samp on columns"
type holder_var_samp_fields {
  hdao_balance: Float
}

"aggregate variance on columns"
type holder_variance_fields {
  hdao_balance: Float
}

"columns and relationships of \"hic_et_nunc.shareholder\""
type shareholder {
  "An object relationship"
  holder: holder!
  holder_id: String!
  "unspecified: unspecified\\ncore_participant: core_participant\\nbenefactor: benefactor"
  holder_type: String!
  id: Int!
  shares: bigint!
  "An object relationship"
  split_contract: splitcontract!
  split_contract_id: Int!
}

"aggregated selection of \"hic_et_nunc.shareholder\""
type shareholder_aggregate {
  aggregate: shareholder_aggregate_fields
  nodes: [shareholder!]!
}

"aggregate fields of \"hic_et_nunc.shareholder\""
type shareholder_aggregate_fields {
  avg: shareholder_avg_fields
  count(columns: [shareholder_select_column!], distinct: Boolean): Int!
  max: shareholder_max_fields
  min: shareholder_min_fields
  stddev: shareholder_stddev_fields
  stddev_pop: shareholder_stddev_pop_fields
  stddev_samp: shareholder_stddev_samp_fields
  sum: shareholder_sum_fields
  var_pop: shareholder_var_pop_fields
  var_samp: shareholder_var_samp_fields
  variance: shareholder_variance_fields
}

"aggregate avg on columns"
type shareholder_avg_fields {
  id: Float
  shares: Float
  split_contract_id: Float
}

"aggregate max on columns"
type shareholder_max_fields {
  holder_id: String
  "unspecified: unspecified\\ncore_participant: core_participant\\nbenefactor: benefactor"
  holder_type: String
  id: Int
  shares: bigint
  split_contract_id: Int
}

"aggregate min on columns"
type shareholder_min_fields {
  holder_id: String
  "unspecified: unspecified\\ncore_participant: core_participant\\nbenefactor: benefactor"
  holder_type: String
  id: Int
  shares: bigint
  split_contract_id: Int
}

"aggregate stddev on columns"
type shareholder_stddev_fields {
  id: Float
  shares: Float
  split_contract_id: Float
}

"aggregate stddev_pop on columns"
type shareholder_stddev_pop_fields {
  id: Float
  shares: Float
  split_contract_id: Float
}

"aggregate stddev_samp on columns"
type shareholder_stddev_samp_fields {
  id: Float
  shares: Float
  split_contract_id: Float
}

"aggregate sum on columns"
type shareholder_sum_fields {
  id: Int
  shares: bigint
  split_contract_id: Int
}

"aggregate var_pop on columns"
type shareholder_var_pop_fields {
  id: Float
  shares: Float
  split_contract_id: Float
}

"aggregate var_samp on columns"
type shareholder_var_samp_fields {
  id: Float
  shares: Float
  split_contract_id: Float
}

"aggregate variance on columns"
type shareholder_variance_fields {
  id: Float
  shares: Float
  split_contract_id: Float
}

"columns and relationships of \"hic_et_nunc.split_signatures\""
type hic_et_nunc_split_signatures {
  "An object relationship"
  holder: holder!
  holder_id: String!
  id: Int!
  "An object relationship"
  token: token!
  token_id: bigint!
}

"aggregated selection of \"hic_et_nunc.split_signatures\""
type hic_et_nunc_split_signatures_aggregate {
  aggregate: hic_et_nunc_split_signatures_aggregate_fields
  nodes: [hic_et_nunc_split_signatures!]!
}

"aggregate fields of \"hic_et_nunc.split_signatures\""
type hic_et_nunc_split_signatures_aggregate_fields {
  avg: hic_et_nunc_split_signatures_avg_fields
  count(
    columns: [hic_et_nunc_split_signatures_select_column!]
    distinct: Boolean
  ): Int!
  max: hic_et_nunc_split_signatures_max_fields
  min: hic_et_nunc_split_signatures_min_fields
  stddev: hic_et_nunc_split_signatures_stddev_fields
  stddev_pop: hic_et_nunc_split_signatures_stddev_pop_fields
  stddev_samp: hic_et_nunc_split_signatures_stddev_samp_fields
  sum: hic_et_nunc_split_signatures_sum_fields
  var_pop: hic_et_nunc_split_signatures_var_pop_fields
  var_samp: hic_et_nunc_split_signatures_var_samp_fields
  variance: hic_et_nunc_split_signatures_variance_fields
}

"aggregate avg on columns"
type hic_et_nunc_split_signatures_avg_fields {
  id: Float
  token_id: Float
}

"aggregate max on columns"
type hic_et_nunc_split_signatures_max_fields {
  holder_id: String
  id: Int
  token_id: bigint
}

"aggregate min on columns"
type hic_et_nunc_split_signatures_min_fields {
  holder_id: String
  id: Int
  token_id: bigint
}

"aggregate stddev on columns"
type hic_et_nunc_split_signatures_stddev_fields {
  id: Float
  token_id: Float
}

"aggregate stddev_pop on columns"
type hic_et_nunc_split_signatures_stddev_pop_fields {
  id: Float
  token_id: Float
}

"aggregate stddev_samp on columns"
type hic_et_nunc_split_signatures_stddev_samp_fields {
  id: Float
  token_id: Float
}

"aggregate sum on columns"
type hic_et_nunc_split_signatures_sum_fields {
  id: Int
  token_id: bigint
}

"aggregate var_pop on columns"
type hic_et_nunc_split_signatures_var_pop_fields {
  id: Float
  token_id: Float
}

"aggregate var_samp on columns"
type hic_et_nunc_split_signatures_var_samp_fields {
  id: Float
  token_id: Float
}

"aggregate variance on columns"
type hic_et_nunc_split_signatures_variance_fields {
  id: Float
  token_id: Float
}

"columns and relationships of \"hic_et_nunc.splitcontract\""
type splitcontract {
  administrator: String!
  "An object relationship"
  contract: holder!
  contract_id: String!
  id: Int!
  "An array relationship"
  shareholder(
    "distinct select on columns"
    distinct_on: [shareholder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [shareholder_order_by!]
    "filter the rows returned"
    where: shareholder_bool_exp
  ): [shareholder!]!
  "An aggregate relationship"
  shareholder_aggregate(
    "distinct select on columns"
    distinct_on: [shareholder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [shareholder_order_by!]
    "filter the rows returned"
    where: shareholder_bool_exp
  ): shareholder_aggregate!
  total_shares: bigint!
}

"aggregated selection of \"hic_et_nunc.splitcontract\""
type splitcontract_aggregate {
  aggregate: splitcontract_aggregate_fields
  nodes: [splitcontract!]!
}

"aggregate fields of \"hic_et_nunc.splitcontract\""
type splitcontract_aggregate_fields {
  avg: splitcontract_avg_fields
  count(columns: [splitcontract_select_column!], distinct: Boolean): Int!
  max: splitcontract_max_fields
  min: splitcontract_min_fields
  stddev: splitcontract_stddev_fields
  stddev_pop: splitcontract_stddev_pop_fields
  stddev_samp: splitcontract_stddev_samp_fields
  sum: splitcontract_sum_fields
  var_pop: splitcontract_var_pop_fields
  var_samp: splitcontract_var_samp_fields
  variance: splitcontract_variance_fields
}

"aggregate avg on columns"
type splitcontract_avg_fields {
  id: Float
  total_shares: Float
}

"aggregate max on columns"
type splitcontract_max_fields {
  administrator: String
  contract_id: String
  id: Int
  total_shares: bigint
}

"aggregate min on columns"
type splitcontract_min_fields {
  administrator: String
  contract_id: String
  id: Int
  total_shares: bigint
}

"aggregate stddev on columns"
type splitcontract_stddev_fields {
  id: Float
  total_shares: Float
}

"aggregate stddev_pop on columns"
type splitcontract_stddev_pop_fields {
  id: Float
  total_shares: Float
}

"aggregate stddev_samp on columns"
type splitcontract_stddev_samp_fields {
  id: Float
  total_shares: Float
}

"aggregate sum on columns"
type splitcontract_sum_fields {
  id: Int
  total_shares: bigint
}

"aggregate var_pop on columns"
type splitcontract_var_pop_fields {
  id: Float
  total_shares: Float
}

"aggregate var_samp on columns"
type splitcontract_var_samp_fields {
  id: Float
  total_shares: Float
}

"aggregate variance on columns"
type splitcontract_variance_fields {
  id: Float
  total_shares: Float
}

"columns and relationships of \"hic_et_nunc.swap\""
type swap {
  amount: smallint!
  amount_left: smallint!
  contract_address: String!
  contract_version: smallint!
  "An object relationship"
  creator: holder!
  creator_id: String!
  "An object relationship"
  fa2: fa2!
  fa2_id: String!
  id: bigint!
  is_valid: Boolean!
  level: bigint!
  ophash: String!
  opid: bigint!
  price: bigint!
  royalties: smallint!
  "ACTIVE: 0\\nFINISHED: 1\\nCANCELED: 2"
  status: smallint!
  timestamp: timestamptz!
  "An object relationship"
  token: token!
  token_id: bigint!
  "An array relationship"
  trades(
    "distinct select on columns"
    distinct_on: [trade_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [trade_order_by!]
    "filter the rows returned"
    where: trade_bool_exp
  ): [trade!]!
  "An aggregate relationship"
  trades_aggregate(
    "distinct select on columns"
    distinct_on: [trade_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [trade_order_by!]
    "filter the rows returned"
    where: trade_bool_exp
  ): trade_aggregate!
}

"aggregated selection of \"hic_et_nunc.swap\""
type swap_aggregate {
  aggregate: swap_aggregate_fields
  nodes: [swap!]!
}

"aggregate fields of \"hic_et_nunc.swap\""
type swap_aggregate_fields {
  avg: swap_avg_fields
  count(columns: [swap_select_column!], distinct: Boolean): Int!
  max: swap_max_fields
  min: swap_min_fields
  stddev: swap_stddev_fields
  stddev_pop: swap_stddev_pop_fields
  stddev_samp: swap_stddev_samp_fields
  sum: swap_sum_fields
  var_pop: swap_var_pop_fields
  var_samp: swap_var_samp_fields
  variance: swap_variance_fields
}

"aggregate avg on columns"
type swap_avg_fields {
  amount: Float
  amount_left: Float
  contract_version: Float
  id: Float
  level: Float
  opid: Float
  price: Float
  royalties: Float
  "ACTIVE: 0\\nFINISHED: 1\\nCANCELED: 2"
  status: Float
  token_id: Float
}

"aggregate max on columns"
type swap_max_fields {
  amount: smallint
  amount_left: smallint
  contract_address: String
  contract_version: smallint
  creator_id: String
  fa2_id: String
  id: bigint
  level: bigint
  ophash: String
  opid: bigint
  price: bigint
  royalties: smallint
  "ACTIVE: 0\\nFINISHED: 1\\nCANCELED: 2"
  status: smallint
  timestamp: timestamptz
  token_id: bigint
}

"aggregate min on columns"
type swap_min_fields {
  amount: smallint
  amount_left: smallint
  contract_address: String
  contract_version: smallint
  creator_id: String
  fa2_id: String
  id: bigint
  level: bigint
  ophash: String
  opid: bigint
  price: bigint
  royalties: smallint
  "ACTIVE: 0\\nFINISHED: 1\\nCANCELED: 2"
  status: smallint
  timestamp: timestamptz
  token_id: bigint
}

"aggregate stddev on columns"
type swap_stddev_fields {
  amount: Float
  amount_left: Float
  contract_version: Float
  id: Float
  level: Float
  opid: Float
  price: Float
  royalties: Float
  "ACTIVE: 0\\nFINISHED: 1\\nCANCELED: 2"
  status: Float
  token_id: Float
}

"aggregate stddev_pop on columns"
type swap_stddev_pop_fields {
  amount: Float
  amount_left: Float
  contract_version: Float
  id: Float
  level: Float
  opid: Float
  price: Float
  royalties: Float
  "ACTIVE: 0\\nFINISHED: 1\\nCANCELED: 2"
  status: Float
  token_id: Float
}

"aggregate stddev_samp on columns"
type swap_stddev_samp_fields {
  amount: Float
  amount_left: Float
  contract_version: Float
  id: Float
  level: Float
  opid: Float
  price: Float
  royalties: Float
  "ACTIVE: 0\\nFINISHED: 1\\nCANCELED: 2"
  status: Float
  token_id: Float
}

"aggregate sum on columns"
type swap_sum_fields {
  amount: smallint
  amount_left: smallint
  contract_version: smallint
  id: bigint
  level: bigint
  opid: bigint
  price: bigint
  royalties: smallint
  "ACTIVE: 0\\nFINISHED: 1\\nCANCELED: 2"
  status: smallint
  token_id: bigint
}

"aggregate var_pop on columns"
type swap_var_pop_fields {
  amount: Float
  amount_left: Float
  contract_version: Float
  id: Float
  level: Float
  opid: Float
  price: Float
  royalties: Float
  "ACTIVE: 0\\nFINISHED: 1\\nCANCELED: 2"
  status: Float
  token_id: Float
}

"aggregate var_samp on columns"
type swap_var_samp_fields {
  amount: Float
  amount_left: Float
  contract_version: Float
  id: Float
  level: Float
  opid: Float
  price: Float
  royalties: Float
  "ACTIVE: 0\\nFINISHED: 1\\nCANCELED: 2"
  status: Float
  token_id: Float
}

"aggregate variance on columns"
type swap_variance_fields {
  amount: Float
  amount_left: Float
  contract_version: Float
  id: Float
  level: Float
  opid: Float
  price: Float
  royalties: Float
  "ACTIVE: 0\\nFINISHED: 1\\nCANCELED: 2"
  status: Float
  token_id: Float
}

"columns and relationships of \"hic_et_nunc.tag\""
type hic_et_nunc_tag {
  id: bigint!
  tag: String!
  "An array relationship"
  tag_tokens(
    "distinct select on columns"
    distinct_on: [token_tag_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_tag_order_by!]
    "filter the rows returned"
    where: token_tag_bool_exp
  ): [token_tag!]!
  "An aggregate relationship"
  tag_tokens_aggregate(
    "distinct select on columns"
    distinct_on: [token_tag_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_tag_order_by!]
    "filter the rows returned"
    where: token_tag_bool_exp
  ): token_tag_aggregate!
}

"aggregated selection of \"hic_et_nunc.tag\""
type hic_et_nunc_tag_aggregate {
  aggregate: hic_et_nunc_tag_aggregate_fields
  nodes: [hic_et_nunc_tag!]!
}

"aggregate fields of \"hic_et_nunc.tag\""
type hic_et_nunc_tag_aggregate_fields {
  avg: hic_et_nunc_tag_avg_fields
  count(columns: [hic_et_nunc_tag_select_column!], distinct: Boolean): Int!
  max: hic_et_nunc_tag_max_fields
  min: hic_et_nunc_tag_min_fields
  stddev: hic_et_nunc_tag_stddev_fields
  stddev_pop: hic_et_nunc_tag_stddev_pop_fields
  stddev_samp: hic_et_nunc_tag_stddev_samp_fields
  sum: hic_et_nunc_tag_sum_fields
  var_pop: hic_et_nunc_tag_var_pop_fields
  var_samp: hic_et_nunc_tag_var_samp_fields
  variance: hic_et_nunc_tag_variance_fields
}

"aggregate avg on columns"
type hic_et_nunc_tag_avg_fields {
  id: Float
}

"aggregate max on columns"
type hic_et_nunc_tag_max_fields {
  id: bigint
  tag: String
}

"aggregate min on columns"
type hic_et_nunc_tag_min_fields {
  id: bigint
  tag: String
}

"aggregate stddev on columns"
type hic_et_nunc_tag_stddev_fields {
  id: Float
}

"aggregate stddev_pop on columns"
type hic_et_nunc_tag_stddev_pop_fields {
  id: Float
}

"aggregate stddev_samp on columns"
type hic_et_nunc_tag_stddev_samp_fields {
  id: Float
}

"aggregate sum on columns"
type hic_et_nunc_tag_sum_fields {
  id: bigint
}

"aggregate var_pop on columns"
type hic_et_nunc_tag_var_pop_fields {
  id: Float
}

"aggregate var_samp on columns"
type hic_et_nunc_tag_var_samp_fields {
  id: Float
}

"aggregate variance on columns"
type hic_et_nunc_tag_variance_fields {
  id: Float
}

"columns and relationships of \"hic_et_nunc.token\""
type token {
  artifact_uri: String!
  "An object relationship"
  creator: holder
  creator_id: String
  description: String!
  display_uri: String!
  extra("JSON select path" path: String): jsonb!
  hdao_balance: bigint!
  id: bigint!
  is_signed: Boolean!
  level: bigint!
  metadata: String!
  mime: String!
  "An array relationship"
  operators(
    "distinct select on columns"
    distinct_on: [token_operator_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_operator_order_by!]
    "filter the rows returned"
    where: token_operator_bool_exp
  ): [token_operator!]!
  "An aggregate relationship"
  operators_aggregate(
    "distinct select on columns"
    distinct_on: [token_operator_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_operator_order_by!]
    "filter the rows returned"
    where: token_operator_bool_exp
  ): token_operator_aggregate!
  royalties: smallint!
  supply: smallint!
  "An array relationship"
  swaps(
    "distinct select on columns"
    distinct_on: [swap_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [swap_order_by!]
    "filter the rows returned"
    where: swap_bool_exp
  ): [swap!]!
  "An aggregate relationship"
  swaps_aggregate(
    "distinct select on columns"
    distinct_on: [swap_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [swap_order_by!]
    "filter the rows returned"
    where: swap_bool_exp
  ): swap_aggregate!
  thumbnail_uri: String!
  timestamp: timestamptz!
  title: String!
  "An array relationship"
  token_holders(
    "distinct select on columns"
    distinct_on: [token_holder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_holder_order_by!]
    "filter the rows returned"
    where: token_holder_bool_exp
  ): [token_holder!]!
  "An aggregate relationship"
  token_holders_aggregate(
    "distinct select on columns"
    distinct_on: [token_holder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_holder_order_by!]
    "filter the rows returned"
    where: token_holder_bool_exp
  ): token_holder_aggregate!
  "An array relationship"
  token_signatures(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_split_signatures_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_split_signatures_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_split_signatures_bool_exp
  ): [hic_et_nunc_split_signatures!]!
  "An aggregate relationship"
  token_signatures_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_split_signatures_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_split_signatures_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_split_signatures_bool_exp
  ): hic_et_nunc_split_signatures_aggregate!
  "An array relationship"
  token_tags(
    "distinct select on columns"
    distinct_on: [token_tag_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_tag_order_by!]
    "filter the rows returned"
    where: token_tag_bool_exp
  ): [token_tag!]!
  "An aggregate relationship"
  token_tags_aggregate(
    "distinct select on columns"
    distinct_on: [token_tag_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_tag_order_by!]
    "filter the rows returned"
    where: token_tag_bool_exp
  ): token_tag_aggregate!
  "An array relationship"
  trades(
    "distinct select on columns"
    distinct_on: [trade_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [trade_order_by!]
    "filter the rows returned"
    where: trade_bool_exp
  ): [trade!]!
  "An aggregate relationship"
  trades_aggregate(
    "distinct select on columns"
    distinct_on: [trade_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [trade_order_by!]
    "filter the rows returned"
    where: trade_bool_exp
  ): trade_aggregate!
}

"aggregated selection of \"hic_et_nunc.token\""
type token_aggregate {
  aggregate: token_aggregate_fields
  nodes: [token!]!
}

"aggregate fields of \"hic_et_nunc.token\""
type token_aggregate_fields {
  avg: token_avg_fields
  count(columns: [token_select_column!], distinct: Boolean): Int!
  max: token_max_fields
  min: token_min_fields
  stddev: token_stddev_fields
  stddev_pop: token_stddev_pop_fields
  stddev_samp: token_stddev_samp_fields
  sum: token_sum_fields
  var_pop: token_var_pop_fields
  var_samp: token_var_samp_fields
  variance: token_variance_fields
}

"aggregate avg on columns"
type token_avg_fields {
  hdao_balance: Float
  id: Float
  level: Float
  royalties: Float
  supply: Float
}

"columns and relationships of \"hic_et_nunc.token_holder\""
type token_holder {
  "An object relationship"
  holder: holder!
  holder_id: String!
  id: Int!
  quantity: bigint!
  "An object relationship"
  token: token!
  token_id: bigint!
}

"aggregated selection of \"hic_et_nunc.token_holder\""
type token_holder_aggregate {
  aggregate: token_holder_aggregate_fields
  nodes: [token_holder!]!
}

"aggregate fields of \"hic_et_nunc.token_holder\""
type token_holder_aggregate_fields {
  avg: token_holder_avg_fields
  count(columns: [token_holder_select_column!], distinct: Boolean): Int!
  max: token_holder_max_fields
  min: token_holder_min_fields
  stddev: token_holder_stddev_fields
  stddev_pop: token_holder_stddev_pop_fields
  stddev_samp: token_holder_stddev_samp_fields
  sum: token_holder_sum_fields
  var_pop: token_holder_var_pop_fields
  var_samp: token_holder_var_samp_fields
  variance: token_holder_variance_fields
}

"aggregate avg on columns"
type token_holder_avg_fields {
  id: Float
  quantity: Float
  token_id: Float
}

"aggregate max on columns"
type token_holder_max_fields {
  holder_id: String
  id: Int
  quantity: bigint
  token_id: bigint
}

"aggregate min on columns"
type token_holder_min_fields {
  holder_id: String
  id: Int
  quantity: bigint
  token_id: bigint
}

"aggregate stddev on columns"
type token_holder_stddev_fields {
  id: Float
  quantity: Float
  token_id: Float
}

"aggregate stddev_pop on columns"
type token_holder_stddev_pop_fields {
  id: Float
  quantity: Float
  token_id: Float
}

"aggregate stddev_samp on columns"
type token_holder_stddev_samp_fields {
  id: Float
  quantity: Float
  token_id: Float
}

"aggregate sum on columns"
type token_holder_sum_fields {
  id: Int
  quantity: bigint
  token_id: bigint
}

"aggregate var_pop on columns"
type token_holder_var_pop_fields {
  id: Float
  quantity: Float
  token_id: Float
}

"aggregate var_samp on columns"
type token_holder_var_samp_fields {
  id: Float
  quantity: Float
  token_id: Float
}

"aggregate variance on columns"
type token_holder_variance_fields {
  id: Float
  quantity: Float
  token_id: Float
}

"aggregate max on columns"
type token_max_fields {
  artifact_uri: String
  creator_id: String
  description: String
  display_uri: String
  hdao_balance: bigint
  id: bigint
  level: bigint
  metadata: String
  mime: String
  royalties: smallint
  supply: smallint
  thumbnail_uri: String
  timestamp: timestamptz
  title: String
}

"aggregate min on columns"
type token_min_fields {
  artifact_uri: String
  creator_id: String
  description: String
  display_uri: String
  hdao_balance: bigint
  id: bigint
  level: bigint
  metadata: String
  mime: String
  royalties: smallint
  supply: smallint
  thumbnail_uri: String
  timestamp: timestamptz
  title: String
}

"columns and relationships of \"hic_et_nunc.token_operator\""
type token_operator {
  id: Int!
  level: bigint!
  operator: String!
  "An object relationship"
  owner: holder!
  owner_id: String!
  "An object relationship"
  token: token!
  token_id: bigint!
}

"aggregated selection of \"hic_et_nunc.token_operator\""
type token_operator_aggregate {
  aggregate: token_operator_aggregate_fields
  nodes: [token_operator!]!
}

"aggregate fields of \"hic_et_nunc.token_operator\""
type token_operator_aggregate_fields {
  avg: token_operator_avg_fields
  count(columns: [token_operator_select_column!], distinct: Boolean): Int!
  max: token_operator_max_fields
  min: token_operator_min_fields
  stddev: token_operator_stddev_fields
  stddev_pop: token_operator_stddev_pop_fields
  stddev_samp: token_operator_stddev_samp_fields
  sum: token_operator_sum_fields
  var_pop: token_operator_var_pop_fields
  var_samp: token_operator_var_samp_fields
  variance: token_operator_variance_fields
}

"aggregate avg on columns"
type token_operator_avg_fields {
  id: Float
  level: Float
  token_id: Float
}

"aggregate max on columns"
type token_operator_max_fields {
  id: Int
  level: bigint
  operator: String
  owner_id: String
  token_id: bigint
}

"aggregate min on columns"
type token_operator_min_fields {
  id: Int
  level: bigint
  operator: String
  owner_id: String
  token_id: bigint
}

"aggregate stddev on columns"
type token_operator_stddev_fields {
  id: Float
  level: Float
  token_id: Float
}

"aggregate stddev_pop on columns"
type token_operator_stddev_pop_fields {
  id: Float
  level: Float
  token_id: Float
}

"aggregate stddev_samp on columns"
type token_operator_stddev_samp_fields {
  id: Float
  level: Float
  token_id: Float
}

"aggregate sum on columns"
type token_operator_sum_fields {
  id: Int
  level: bigint
  token_id: bigint
}

"aggregate var_pop on columns"
type token_operator_var_pop_fields {
  id: Float
  level: Float
  token_id: Float
}

"aggregate var_samp on columns"
type token_operator_var_samp_fields {
  id: Float
  level: Float
  token_id: Float
}

"aggregate variance on columns"
type token_operator_variance_fields {
  id: Float
  level: Float
  token_id: Float
}

"aggregate stddev on columns"
type token_stddev_fields {
  hdao_balance: Float
  id: Float
  level: Float
  royalties: Float
  supply: Float
}

"aggregate stddev_pop on columns"
type token_stddev_pop_fields {
  hdao_balance: Float
  id: Float
  level: Float
  royalties: Float
  supply: Float
}

"aggregate stddev_samp on columns"
type token_stddev_samp_fields {
  hdao_balance: Float
  id: Float
  level: Float
  royalties: Float
  supply: Float
}

"aggregate sum on columns"
type token_sum_fields {
  hdao_balance: bigint
  id: bigint
  level: bigint
  royalties: smallint
  supply: smallint
}

"columns and relationships of \"hic_et_nunc.token_tag\""
type token_tag {
  id: Int!
  "An object relationship"
  tag: hic_et_nunc_tag!
  tag_id: bigint!
  "An object relationship"
  token: token!
  token_id: bigint!
}

"aggregated selection of \"hic_et_nunc.token_tag\""
type token_tag_aggregate {
  aggregate: token_tag_aggregate_fields
  nodes: [token_tag!]!
}

"aggregate fields of \"hic_et_nunc.token_tag\""
type token_tag_aggregate_fields {
  avg: token_tag_avg_fields
  count(columns: [token_tag_select_column!], distinct: Boolean): Int!
  max: token_tag_max_fields
  min: token_tag_min_fields
  stddev: token_tag_stddev_fields
  stddev_pop: token_tag_stddev_pop_fields
  stddev_samp: token_tag_stddev_samp_fields
  sum: token_tag_sum_fields
  var_pop: token_tag_var_pop_fields
  var_samp: token_tag_var_samp_fields
  variance: token_tag_variance_fields
}

"aggregate avg on columns"
type token_tag_avg_fields {
  id: Float
  tag_id: Float
  token_id: Float
}

"aggregate max on columns"
type token_tag_max_fields {
  id: Int
  tag_id: bigint
  token_id: bigint
}

"aggregate min on columns"
type token_tag_min_fields {
  id: Int
  tag_id: bigint
  token_id: bigint
}

"aggregate stddev on columns"
type token_tag_stddev_fields {
  id: Float
  tag_id: Float
  token_id: Float
}

"aggregate stddev_pop on columns"
type token_tag_stddev_pop_fields {
  id: Float
  tag_id: Float
  token_id: Float
}

"aggregate stddev_samp on columns"
type token_tag_stddev_samp_fields {
  id: Float
  tag_id: Float
  token_id: Float
}

"aggregate sum on columns"
type token_tag_sum_fields {
  id: Int
  tag_id: bigint
  token_id: bigint
}

"aggregate var_pop on columns"
type token_tag_var_pop_fields {
  id: Float
  tag_id: Float
  token_id: Float
}

"aggregate var_samp on columns"
type token_tag_var_samp_fields {
  id: Float
  tag_id: Float
  token_id: Float
}

"aggregate variance on columns"
type token_tag_variance_fields {
  id: Float
  tag_id: Float
  token_id: Float
}

"aggregate var_pop on columns"
type token_var_pop_fields {
  hdao_balance: Float
  id: Float
  level: Float
  royalties: Float
  supply: Float
}

"aggregate var_samp on columns"
type token_var_samp_fields {
  hdao_balance: Float
  id: Float
  level: Float
  royalties: Float
  supply: Float
}

"aggregate variance on columns"
type token_variance_fields {
  hdao_balance: Float
  id: Float
  level: Float
  royalties: Float
  supply: Float
}

"columns and relationships of \"hic_et_nunc.trade\""
type trade {
  amount: bigint!
  "An object relationship"
  buyer: holder!
  buyer_id: String!
  id: bigint!
  level: bigint!
  ophash: String!
  "An object relationship"
  seller: holder!
  seller_id: String!
  "An object relationship"
  swap: swap!
  swap_id: bigint!
  timestamp: timestamptz!
  "An object relationship"
  token: token!
  token_id: bigint!
}

"aggregated selection of \"hic_et_nunc.trade\""
type trade_aggregate {
  aggregate: trade_aggregate_fields
  nodes: [trade!]!
}

"aggregate fields of \"hic_et_nunc.trade\""
type trade_aggregate_fields {
  avg: trade_avg_fields
  count(columns: [trade_select_column!], distinct: Boolean): Int!
  max: trade_max_fields
  min: trade_min_fields
  stddev: trade_stddev_fields
  stddev_pop: trade_stddev_pop_fields
  stddev_samp: trade_stddev_samp_fields
  sum: trade_sum_fields
  var_pop: trade_var_pop_fields
  var_samp: trade_var_samp_fields
  variance: trade_variance_fields
}

"aggregate avg on columns"
type trade_avg_fields {
  amount: Float
  id: Float
  level: Float
  swap_id: Float
  token_id: Float
}

"aggregate max on columns"
type trade_max_fields {
  amount: bigint
  buyer_id: String
  id: bigint
  level: bigint
  ophash: String
  seller_id: String
  swap_id: bigint
  timestamp: timestamptz
  token_id: bigint
}

"aggregate min on columns"
type trade_min_fields {
  amount: bigint
  buyer_id: String
  id: bigint
  level: bigint
  ophash: String
  seller_id: String
  swap_id: bigint
  timestamp: timestamptz
  token_id: bigint
}

"aggregate stddev on columns"
type trade_stddev_fields {
  amount: Float
  id: Float
  level: Float
  swap_id: Float
  token_id: Float
}

"aggregate stddev_pop on columns"
type trade_stddev_pop_fields {
  amount: Float
  id: Float
  level: Float
  swap_id: Float
  token_id: Float
}

"aggregate stddev_samp on columns"
type trade_stddev_samp_fields {
  amount: Float
  id: Float
  level: Float
  swap_id: Float
  token_id: Float
}

"aggregate sum on columns"
type trade_sum_fields {
  amount: bigint
  id: bigint
  level: bigint
  swap_id: bigint
  token_id: bigint
}

"aggregate var_pop on columns"
type trade_var_pop_fields {
  amount: Float
  id: Float
  level: Float
  swap_id: Float
  token_id: Float
}

"aggregate var_samp on columns"
type trade_var_samp_fields {
  amount: Float
  id: Float
  level: Float
  swap_id: Float
  token_id: Float
}

"aggregate variance on columns"
type trade_variance_fields {
  amount: Float
  id: Float
  level: Float
  swap_id: Float
  token_id: Float
}

type query_root {
  "fetch data from the table: \"hic_et_nunc.ask\""
  hic_et_nunc_ask(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_ask_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_ask_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_ask_bool_exp
  ): [hic_et_nunc_ask!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.ask\""
  hic_et_nunc_ask_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_ask_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_ask_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_ask_bool_exp
  ): hic_et_nunc_ask_aggregate!
  "fetch data from the table: \"hic_et_nunc.ask\" using primary key columns"
  hic_et_nunc_ask_by_pk(id: bigint!): hic_et_nunc_ask
  "fetch data from the table: \"hic_et_nunc.bid\""
  hic_et_nunc_bid(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_bid_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_bid_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_bid_bool_exp
  ): [hic_et_nunc_bid!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.bid\""
  hic_et_nunc_bid_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_bid_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_bid_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_bid_bool_exp
  ): hic_et_nunc_bid_aggregate!
  "fetch data from the table: \"hic_et_nunc.bid\" using primary key columns"
  hic_et_nunc_bid_by_pk(id: bigint!): hic_et_nunc_bid
  "fetch data from the table: \"hic_et_nunc.dipdup_state\""
  dipdup_index(
    "distinct select on columns"
    distinct_on: [dipdup_index_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [dipdup_index_order_by!]
    "filter the rows returned"
    where: dipdup_index_bool_exp
  ): [dipdup_index!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.dipdup_state\""
  dipdup_index_aggregate(
    "distinct select on columns"
    distinct_on: [dipdup_index_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [dipdup_index_order_by!]
    "filter the rows returned"
    where: dipdup_index_bool_exp
  ): dipdup_index_aggregate!
  "fetch data from the table: \"hic_et_nunc.dipdup_state\" using primary key columns"
  dipdup_index_by_pk(index_name: String!): dipdup_index
  "fetch data from the table: \"hic_et_nunc.dutch_auction\""
  hic_et_nunc_dutch_auction(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_dutch_auction_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_dutch_auction_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_dutch_auction_bool_exp
  ): [hic_et_nunc_dutch_auction!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.dutch_auction\""
  hic_et_nunc_dutch_auction_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_dutch_auction_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_dutch_auction_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_dutch_auction_bool_exp
  ): hic_et_nunc_dutch_auction_aggregate!
  "fetch data from the table: \"hic_et_nunc.dutch_auction\" using primary key columns"
  hic_et_nunc_dutch_auction_by_pk(id: bigint!): hic_et_nunc_dutch_auction
  "fetch data from the table: \"hic_et_nunc.english_auction\""
  hic_et_nunc_english_auction(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_english_auction_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_english_auction_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_english_auction_bool_exp
  ): [hic_et_nunc_english_auction!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.english_auction\""
  hic_et_nunc_english_auction_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_english_auction_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_english_auction_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_english_auction_bool_exp
  ): hic_et_nunc_english_auction_aggregate!
  "fetch data from the table: \"hic_et_nunc.english_auction\" using primary key columns"
  hic_et_nunc_english_auction_by_pk(id: bigint!): hic_et_nunc_english_auction
  "fetch data from the table: \"hic_et_nunc.english_bid\""
  hic_et_nunc_english_bid(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_english_bid_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_english_bid_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_english_bid_bool_exp
  ): [hic_et_nunc_english_bid!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.english_bid\""
  hic_et_nunc_english_bid_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_english_bid_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_english_bid_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_english_bid_bool_exp
  ): hic_et_nunc_english_bid_aggregate!
  "fetch data from the table: \"hic_et_nunc.english_bid\" using primary key columns"
  hic_et_nunc_english_bid_by_pk(id: bigint!): hic_et_nunc_english_bid
  "fetch data from the table: \"hic_et_nunc.fa2\""
  fa2(
    "distinct select on columns"
    distinct_on: [fa2_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fa2_order_by!]
    "filter the rows returned"
    where: fa2_bool_exp
  ): [fa2!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.fa2\""
  fa2_aggregate(
    "distinct select on columns"
    distinct_on: [fa2_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fa2_order_by!]
    "filter the rows returned"
    where: fa2_bool_exp
  ): fa2_aggregate!
  "fetch data from the table: \"hic_et_nunc.fa2\" using primary key columns"
  fa2_by_pk(contract: String!): fa2
  "fetch data from the table: \"hic_et_nunc.fulfilled_ask\""
  hic_et_nunc_fulfilled_ask(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_fulfilled_ask_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_fulfilled_ask_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_fulfilled_ask_bool_exp
  ): [hic_et_nunc_fulfilled_ask!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.fulfilled_ask\""
  hic_et_nunc_fulfilled_ask_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_fulfilled_ask_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_fulfilled_ask_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_fulfilled_ask_bool_exp
  ): hic_et_nunc_fulfilled_ask_aggregate!
  "fetch data from the table: \"hic_et_nunc.fulfilled_ask\" using primary key columns"
  hic_et_nunc_fulfilled_ask_by_pk(id: bigint!): hic_et_nunc_fulfilled_ask
  "fetch data from the table: \"hic_et_nunc.holder\""
  holder(
    "distinct select on columns"
    distinct_on: [holder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [holder_order_by!]
    "filter the rows returned"
    where: holder_bool_exp
  ): [holder!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.holder\""
  holder_aggregate(
    "distinct select on columns"
    distinct_on: [holder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [holder_order_by!]
    "filter the rows returned"
    where: holder_bool_exp
  ): holder_aggregate!
  "fetch data from the table: \"hic_et_nunc.holder\" using primary key columns"
  holder_by_pk(address: String!): holder
  "fetch data from the table: \"hic_et_nunc.shareholder\""
  shareholder(
    "distinct select on columns"
    distinct_on: [shareholder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [shareholder_order_by!]
    "filter the rows returned"
    where: shareholder_bool_exp
  ): [shareholder!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.shareholder\""
  shareholder_aggregate(
    "distinct select on columns"
    distinct_on: [shareholder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [shareholder_order_by!]
    "filter the rows returned"
    where: shareholder_bool_exp
  ): shareholder_aggregate!
  "fetch data from the table: \"hic_et_nunc.shareholder\" using primary key columns"
  shareholder_by_pk(id: Int!): shareholder
  "fetch data from the table: \"hic_et_nunc.split_signatures\""
  hic_et_nunc_split_signatures(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_split_signatures_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_split_signatures_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_split_signatures_bool_exp
  ): [hic_et_nunc_split_signatures!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.split_signatures\""
  hic_et_nunc_split_signatures_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_split_signatures_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_split_signatures_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_split_signatures_bool_exp
  ): hic_et_nunc_split_signatures_aggregate!
  "fetch data from the table: \"hic_et_nunc.split_signatures\" using primary key columns"
  hic_et_nunc_split_signatures_by_pk(id: Int!): hic_et_nunc_split_signatures
  "fetch data from the table: \"hic_et_nunc.splitcontract\""
  splitcontract(
    "distinct select on columns"
    distinct_on: [splitcontract_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [splitcontract_order_by!]
    "filter the rows returned"
    where: splitcontract_bool_exp
  ): [splitcontract!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.splitcontract\""
  splitcontract_aggregate(
    "distinct select on columns"
    distinct_on: [splitcontract_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [splitcontract_order_by!]
    "filter the rows returned"
    where: splitcontract_bool_exp
  ): splitcontract_aggregate!
  "fetch data from the table: \"hic_et_nunc.splitcontract\" using primary key columns"
  splitcontract_by_pk(id: Int!): splitcontract
  "fetch data from the table: \"hic_et_nunc.swap\""
  swap(
    "distinct select on columns"
    distinct_on: [swap_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [swap_order_by!]
    "filter the rows returned"
    where: swap_bool_exp
  ): [swap!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.swap\""
  swap_aggregate(
    "distinct select on columns"
    distinct_on: [swap_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [swap_order_by!]
    "filter the rows returned"
    where: swap_bool_exp
  ): swap_aggregate!
  "fetch data from the table: \"hic_et_nunc.swap\" using primary key columns"
  swap_by_pk(opid: bigint!): swap
  "fetch data from the table: \"hic_et_nunc.tag\""
  hic_et_nunc_tag(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_tag_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_tag_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_tag_bool_exp
  ): [hic_et_nunc_tag!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.tag\""
  hic_et_nunc_tag_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_tag_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_tag_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_tag_bool_exp
  ): hic_et_nunc_tag_aggregate!
  "fetch data from the table: \"hic_et_nunc.tag\" using primary key columns"
  hic_et_nunc_tag_by_pk(id: bigint!): hic_et_nunc_tag
  "fetch data from the table: \"hic_et_nunc.token\""
  token(
    "distinct select on columns"
    distinct_on: [token_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_order_by!]
    "filter the rows returned"
    where: token_bool_exp
  ): [token!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.token\""
  token_aggregate(
    "distinct select on columns"
    distinct_on: [token_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_order_by!]
    "filter the rows returned"
    where: token_bool_exp
  ): token_aggregate!
  "fetch data from the table: \"hic_et_nunc.token\" using primary key columns"
  token_by_pk(id: bigint!): token
  "fetch data from the table: \"hic_et_nunc.token_holder\""
  token_holder(
    "distinct select on columns"
    distinct_on: [token_holder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_holder_order_by!]
    "filter the rows returned"
    where: token_holder_bool_exp
  ): [token_holder!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.token_holder\""
  token_holder_aggregate(
    "distinct select on columns"
    distinct_on: [token_holder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_holder_order_by!]
    "filter the rows returned"
    where: token_holder_bool_exp
  ): token_holder_aggregate!
  "fetch data from the table: \"hic_et_nunc.token_holder\" using primary key columns"
  token_holder_by_pk(id: Int!): token_holder
  "fetch data from the table: \"hic_et_nunc.token_operator\""
  token_operator(
    "distinct select on columns"
    distinct_on: [token_operator_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_operator_order_by!]
    "filter the rows returned"
    where: token_operator_bool_exp
  ): [token_operator!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.token_operator\""
  token_operator_aggregate(
    "distinct select on columns"
    distinct_on: [token_operator_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_operator_order_by!]
    "filter the rows returned"
    where: token_operator_bool_exp
  ): token_operator_aggregate!
  "fetch data from the table: \"hic_et_nunc.token_operator\" using primary key columns"
  token_operator_by_pk(id: Int!): token_operator
  "fetch data from the table: \"hic_et_nunc.token_tag\""
  token_tag(
    "distinct select on columns"
    distinct_on: [token_tag_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_tag_order_by!]
    "filter the rows returned"
    where: token_tag_bool_exp
  ): [token_tag!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.token_tag\""
  token_tag_aggregate(
    "distinct select on columns"
    distinct_on: [token_tag_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_tag_order_by!]
    "filter the rows returned"
    where: token_tag_bool_exp
  ): token_tag_aggregate!
  "fetch data from the table: \"hic_et_nunc.token_tag\" using primary key columns"
  token_tag_by_pk(id: Int!): token_tag
  "fetch data from the table: \"hic_et_nunc.trade\""
  trade(
    "distinct select on columns"
    distinct_on: [trade_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [trade_order_by!]
    "filter the rows returned"
    where: trade_bool_exp
  ): [trade!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.trade\""
  trade_aggregate(
    "distinct select on columns"
    distinct_on: [trade_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [trade_order_by!]
    "filter the rows returned"
    where: trade_bool_exp
  ): trade_aggregate!
  "fetch data from the table: \"hic_et_nunc.trade\" using primary key columns"
  trade_by_pk(id: bigint!): trade
}

type subscription_root {
  "fetch data from the table: \"hic_et_nunc.ask\""
  hic_et_nunc_ask(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_ask_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_ask_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_ask_bool_exp
  ): [hic_et_nunc_ask!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.ask\""
  hic_et_nunc_ask_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_ask_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_ask_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_ask_bool_exp
  ): hic_et_nunc_ask_aggregate!
  "fetch data from the table: \"hic_et_nunc.ask\" using primary key columns"
  hic_et_nunc_ask_by_pk(id: bigint!): hic_et_nunc_ask
  "fetch data from the table: \"hic_et_nunc.bid\""
  hic_et_nunc_bid(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_bid_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_bid_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_bid_bool_exp
  ): [hic_et_nunc_bid!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.bid\""
  hic_et_nunc_bid_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_bid_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_bid_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_bid_bool_exp
  ): hic_et_nunc_bid_aggregate!
  "fetch data from the table: \"hic_et_nunc.bid\" using primary key columns"
  hic_et_nunc_bid_by_pk(id: bigint!): hic_et_nunc_bid
  "fetch data from the table: \"hic_et_nunc.dipdup_state\""
  dipdup_index(
    "distinct select on columns"
    distinct_on: [dipdup_index_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [dipdup_index_order_by!]
    "filter the rows returned"
    where: dipdup_index_bool_exp
  ): [dipdup_index!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.dipdup_state\""
  dipdup_index_aggregate(
    "distinct select on columns"
    distinct_on: [dipdup_index_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [dipdup_index_order_by!]
    "filter the rows returned"
    where: dipdup_index_bool_exp
  ): dipdup_index_aggregate!
  "fetch data from the table: \"hic_et_nunc.dipdup_state\" using primary key columns"
  dipdup_index_by_pk(index_name: String!): dipdup_index
  "fetch data from the table: \"hic_et_nunc.dutch_auction\""
  hic_et_nunc_dutch_auction(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_dutch_auction_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_dutch_auction_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_dutch_auction_bool_exp
  ): [hic_et_nunc_dutch_auction!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.dutch_auction\""
  hic_et_nunc_dutch_auction_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_dutch_auction_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_dutch_auction_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_dutch_auction_bool_exp
  ): hic_et_nunc_dutch_auction_aggregate!
  "fetch data from the table: \"hic_et_nunc.dutch_auction\" using primary key columns"
  hic_et_nunc_dutch_auction_by_pk(id: bigint!): hic_et_nunc_dutch_auction
  "fetch data from the table: \"hic_et_nunc.english_auction\""
  hic_et_nunc_english_auction(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_english_auction_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_english_auction_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_english_auction_bool_exp
  ): [hic_et_nunc_english_auction!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.english_auction\""
  hic_et_nunc_english_auction_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_english_auction_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_english_auction_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_english_auction_bool_exp
  ): hic_et_nunc_english_auction_aggregate!
  "fetch data from the table: \"hic_et_nunc.english_auction\" using primary key columns"
  hic_et_nunc_english_auction_by_pk(id: bigint!): hic_et_nunc_english_auction
  "fetch data from the table: \"hic_et_nunc.english_bid\""
  hic_et_nunc_english_bid(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_english_bid_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_english_bid_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_english_bid_bool_exp
  ): [hic_et_nunc_english_bid!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.english_bid\""
  hic_et_nunc_english_bid_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_english_bid_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_english_bid_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_english_bid_bool_exp
  ): hic_et_nunc_english_bid_aggregate!
  "fetch data from the table: \"hic_et_nunc.english_bid\" using primary key columns"
  hic_et_nunc_english_bid_by_pk(id: bigint!): hic_et_nunc_english_bid
  "fetch data from the table: \"hic_et_nunc.fa2\""
  fa2(
    "distinct select on columns"
    distinct_on: [fa2_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fa2_order_by!]
    "filter the rows returned"
    where: fa2_bool_exp
  ): [fa2!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.fa2\""
  fa2_aggregate(
    "distinct select on columns"
    distinct_on: [fa2_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fa2_order_by!]
    "filter the rows returned"
    where: fa2_bool_exp
  ): fa2_aggregate!
  "fetch data from the table: \"hic_et_nunc.fa2\" using primary key columns"
  fa2_by_pk(contract: String!): fa2
  "fetch data from the table: \"hic_et_nunc.fulfilled_ask\""
  hic_et_nunc_fulfilled_ask(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_fulfilled_ask_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_fulfilled_ask_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_fulfilled_ask_bool_exp
  ): [hic_et_nunc_fulfilled_ask!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.fulfilled_ask\""
  hic_et_nunc_fulfilled_ask_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_fulfilled_ask_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_fulfilled_ask_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_fulfilled_ask_bool_exp
  ): hic_et_nunc_fulfilled_ask_aggregate!
  "fetch data from the table: \"hic_et_nunc.fulfilled_ask\" using primary key columns"
  hic_et_nunc_fulfilled_ask_by_pk(id: bigint!): hic_et_nunc_fulfilled_ask
  "fetch data from the table: \"hic_et_nunc.holder\""
  holder(
    "distinct select on columns"
    distinct_on: [holder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [holder_order_by!]
    "filter the rows returned"
    where: holder_bool_exp
  ): [holder!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.holder\""
  holder_aggregate(
    "distinct select on columns"
    distinct_on: [holder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [holder_order_by!]
    "filter the rows returned"
    where: holder_bool_exp
  ): holder_aggregate!
  "fetch data from the table: \"hic_et_nunc.holder\" using primary key columns"
  holder_by_pk(address: String!): holder
  "fetch data from the table: \"hic_et_nunc.shareholder\""
  shareholder(
    "distinct select on columns"
    distinct_on: [shareholder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [shareholder_order_by!]
    "filter the rows returned"
    where: shareholder_bool_exp
  ): [shareholder!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.shareholder\""
  shareholder_aggregate(
    "distinct select on columns"
    distinct_on: [shareholder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [shareholder_order_by!]
    "filter the rows returned"
    where: shareholder_bool_exp
  ): shareholder_aggregate!
  "fetch data from the table: \"hic_et_nunc.shareholder\" using primary key columns"
  shareholder_by_pk(id: Int!): shareholder
  "fetch data from the table: \"hic_et_nunc.split_signatures\""
  hic_et_nunc_split_signatures(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_split_signatures_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_split_signatures_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_split_signatures_bool_exp
  ): [hic_et_nunc_split_signatures!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.split_signatures\""
  hic_et_nunc_split_signatures_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_split_signatures_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_split_signatures_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_split_signatures_bool_exp
  ): hic_et_nunc_split_signatures_aggregate!
  "fetch data from the table: \"hic_et_nunc.split_signatures\" using primary key columns"
  hic_et_nunc_split_signatures_by_pk(id: Int!): hic_et_nunc_split_signatures
  "fetch data from the table: \"hic_et_nunc.splitcontract\""
  splitcontract(
    "distinct select on columns"
    distinct_on: [splitcontract_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [splitcontract_order_by!]
    "filter the rows returned"
    where: splitcontract_bool_exp
  ): [splitcontract!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.splitcontract\""
  splitcontract_aggregate(
    "distinct select on columns"
    distinct_on: [splitcontract_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [splitcontract_order_by!]
    "filter the rows returned"
    where: splitcontract_bool_exp
  ): splitcontract_aggregate!
  "fetch data from the table: \"hic_et_nunc.splitcontract\" using primary key columns"
  splitcontract_by_pk(id: Int!): splitcontract
  "fetch data from the table: \"hic_et_nunc.swap\""
  swap(
    "distinct select on columns"
    distinct_on: [swap_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [swap_order_by!]
    "filter the rows returned"
    where: swap_bool_exp
  ): [swap!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.swap\""
  swap_aggregate(
    "distinct select on columns"
    distinct_on: [swap_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [swap_order_by!]
    "filter the rows returned"
    where: swap_bool_exp
  ): swap_aggregate!
  "fetch data from the table: \"hic_et_nunc.swap\" using primary key columns"
  swap_by_pk(opid: bigint!): swap
  "fetch data from the table: \"hic_et_nunc.tag\""
  hic_et_nunc_tag(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_tag_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_tag_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_tag_bool_exp
  ): [hic_et_nunc_tag!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.tag\""
  hic_et_nunc_tag_aggregate(
    "distinct select on columns"
    distinct_on: [hic_et_nunc_tag_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [hic_et_nunc_tag_order_by!]
    "filter the rows returned"
    where: hic_et_nunc_tag_bool_exp
  ): hic_et_nunc_tag_aggregate!
  "fetch data from the table: \"hic_et_nunc.tag\" using primary key columns"
  hic_et_nunc_tag_by_pk(id: bigint!): hic_et_nunc_tag
  "fetch data from the table: \"hic_et_nunc.token\""
  token(
    "distinct select on columns"
    distinct_on: [token_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_order_by!]
    "filter the rows returned"
    where: token_bool_exp
  ): [token!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.token\""
  token_aggregate(
    "distinct select on columns"
    distinct_on: [token_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_order_by!]
    "filter the rows returned"
    where: token_bool_exp
  ): token_aggregate!
  "fetch data from the table: \"hic_et_nunc.token\" using primary key columns"
  token_by_pk(id: bigint!): token
  "fetch data from the table: \"hic_et_nunc.token_holder\""
  token_holder(
    "distinct select on columns"
    distinct_on: [token_holder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_holder_order_by!]
    "filter the rows returned"
    where: token_holder_bool_exp
  ): [token_holder!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.token_holder\""
  token_holder_aggregate(
    "distinct select on columns"
    distinct_on: [token_holder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_holder_order_by!]
    "filter the rows returned"
    where: token_holder_bool_exp
  ): token_holder_aggregate!
  "fetch data from the table: \"hic_et_nunc.token_holder\" using primary key columns"
  token_holder_by_pk(id: Int!): token_holder
  "fetch data from the table: \"hic_et_nunc.token_operator\""
  token_operator(
    "distinct select on columns"
    distinct_on: [token_operator_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_operator_order_by!]
    "filter the rows returned"
    where: token_operator_bool_exp
  ): [token_operator!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.token_operator\""
  token_operator_aggregate(
    "distinct select on columns"
    distinct_on: [token_operator_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_operator_order_by!]
    "filter the rows returned"
    where: token_operator_bool_exp
  ): token_operator_aggregate!
  "fetch data from the table: \"hic_et_nunc.token_operator\" using primary key columns"
  token_operator_by_pk(id: Int!): token_operator
  "fetch data from the table: \"hic_et_nunc.token_tag\""
  token_tag(
    "distinct select on columns"
    distinct_on: [token_tag_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_tag_order_by!]
    "filter the rows returned"
    where: token_tag_bool_exp
  ): [token_tag!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.token_tag\""
  token_tag_aggregate(
    "distinct select on columns"
    distinct_on: [token_tag_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [token_tag_order_by!]
    "filter the rows returned"
    where: token_tag_bool_exp
  ): token_tag_aggregate!
  "fetch data from the table: \"hic_et_nunc.token_tag\" using primary key columns"
  token_tag_by_pk(id: Int!): token_tag
  "fetch data from the table: \"hic_et_nunc.trade\""
  trade(
    "distinct select on columns"
    distinct_on: [trade_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [trade_order_by!]
    "filter the rows returned"
    where: trade_bool_exp
  ): [trade!]!
  "fetch aggregated fields from the table: \"hic_et_nunc.trade\""
  trade_aggregate(
    "distinct select on columns"
    distinct_on: [trade_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [trade_order_by!]
    "filter the rows returned"
    where: trade_bool_exp
  ): trade_aggregate!
  "fetch data from the table: \"hic_et_nunc.trade\" using primary key columns"
  trade_by_pk(id: bigint!): trade
}

"select columns of table \"hic_et_nunc.ask\""
enum hic_et_nunc_ask_select_column {
  "column name"
  amount
  "column name"
  amount_left
  "column name"
  artist_id
  "column name"
  creator_id
  "column name"
  fa2_id
  "column name"
  id
  "column name"
  level
  "column name"
  objkt_id
  "column name"
  price
  "column name"
  royalties
  "column name"
  status
  "column name"
  timestamp
  "column name"
  update_level
  "column name"
  update_timestamp
}

"select columns of table \"hic_et_nunc.bid\""
enum hic_et_nunc_bid_select_column {
  "column name"
  artist_id
  "column name"
  creator_id
  "column name"
  fa2_id
  "column name"
  id
  "column name"
  level
  "column name"
  objkt_id
  "column name"
  price
  "column name"
  royalties
  "column name"
  seller_id
  "column name"
  status
  "column name"
  timestamp
  "column name"
  update_level
  "column name"
  update_timestamp
}

"select columns of table \"hic_et_nunc.dipdup_state\""
enum dipdup_index_select_column {
  "column name"
  hash
  "column name"
  index_hash
  "column name"
  index_name
  "column name"
  index_type
  "column name"
  level
}

"select columns of table \"hic_et_nunc.dutch_auction\""
enum hic_et_nunc_dutch_auction_select_column {
  "column name"
  artist_id
  "column name"
  buy_price
  "column name"
  buyer_id
  "column name"
  contract_version
  "column name"
  creator_id
  "column name"
  end_price
  "column name"
  end_time
  "column name"
  fa2_id
  "column name"
  hash
  "column name"
  id
  "column name"
  level
  "column name"
  objkt_id
  "column name"
  royalties
  "column name"
  start_price
  "column name"
  start_time
  "column name"
  status
  "column name"
  timestamp
  "column name"
  update_level
  "column name"
  update_timestamp
}

"select columns of table \"hic_et_nunc.english_auction\""
enum hic_et_nunc_english_auction_select_column {
  "column name"
  artist_id
  "column name"
  contract_version
  "column name"
  creator_id
  "column name"
  end_time
  "column name"
  extension_time
  "column name"
  fa2_id
  "column name"
  hash
  "column name"
  id
  "column name"
  level
  "column name"
  objkt_id
  "column name"
  price_increment
  "column name"
  reserve
  "column name"
  royalties
  "column name"
  start_time
  "column name"
  status
  "column name"
  timestamp
  "column name"
  update_level
  "column name"
  update_timestamp
}

"select columns of table \"hic_et_nunc.english_bid\""
enum hic_et_nunc_english_bid_select_column {
  "column name"
  amount
  "column name"
  auction_id
  "column name"
  bidder_id
  "column name"
  id
  "column name"
  level
  "column name"
  timestamp
}

"select columns of table \"hic_et_nunc.fa2\""
enum fa2_select_column {
  "column name"
  contract
}

"select columns of table \"hic_et_nunc.fulfilled_ask\""
enum hic_et_nunc_fulfilled_ask_select_column {
  "column name"
  amount
  "column name"
  ask_id
  "column name"
  buyer_id
  "column name"
  id
  "column name"
  level
  "column name"
  objkt_id
  "column name"
  seller_id
  "column name"
  timestamp
}

"select columns of table \"hic_et_nunc.holder\""
enum holder_select_column {
  "column name"
  address
  "column name"
  description
  "column name"
  hdao_balance
  "column name"
  is_split
  "column name"
  metadata
  "column name"
  metadata_file
  "column name"
  name
}

"select columns of table \"hic_et_nunc.shareholder\""
enum shareholder_select_column {
  "column name"
  holder_id
  "column name"
  holder_type
  "column name"
  id
  "column name"
  shares
  "column name"
  split_contract_id
}

"select columns of table \"hic_et_nunc.split_signatures\""
enum hic_et_nunc_split_signatures_select_column {
  "column name"
  holder_id
  "column name"
  id
  "column name"
  token_id
}

"select columns of table \"hic_et_nunc.splitcontract\""
enum splitcontract_select_column {
  "column name"
  administrator
  "column name"
  contract_id
  "column name"
  id
  "column name"
  total_shares
}

"select columns of table \"hic_et_nunc.swap\""
enum swap_select_column {
  "column name"
  amount
  "column name"
  amount_left
  "column name"
  contract_address
  "column name"
  contract_version
  "column name"
  creator_id
  "column name"
  fa2_id
  "column name"
  id
  "column name"
  is_valid
  "column name"
  level
  "column name"
  ophash
  "column name"
  opid
  "column name"
  price
  "column name"
  royalties
  "column name"
  status
  "column name"
  timestamp
  "column name"
  token_id
}

"select columns of table \"hic_et_nunc.tag\""
enum hic_et_nunc_tag_select_column {
  "column name"
  id
  "column name"
  tag
}

"select columns of table \"hic_et_nunc.token_holder\""
enum token_holder_select_column {
  "column name"
  holder_id
  "column name"
  id
  "column name"
  quantity
  "column name"
  token_id
}

"select columns of table \"hic_et_nunc.token_operator\""
enum token_operator_select_column {
  "column name"
  id
  "column name"
  level
  "column name"
  operator
  "column name"
  owner_id
  "column name"
  token_id
}

"select columns of table \"hic_et_nunc.token\""
enum token_select_column {
  "column name"
  artifact_uri
  "column name"
  creator_id
  "column name"
  description
  "column name"
  display_uri
  "column name"
  extra
  "column name"
  hdao_balance
  "column name"
  id
  "column name"
  is_signed
  "column name"
  level
  "column name"
  metadata
  "column name"
  mime
  "column name"
  royalties
  "column name"
  supply
  "column name"
  thumbnail_uri
  "column name"
  timestamp
  "column name"
  title
}

"select columns of table \"hic_et_nunc.token_tag\""
enum token_tag_select_column {
  "column name"
  id
  "column name"
  tag_id
  "column name"
  token_id
}

"select columns of table \"hic_et_nunc.trade\""
enum trade_select_column {
  "column name"
  amount
  "column name"
  buyer_id
  "column name"
  id
  "column name"
  level
  "column name"
  ophash
  "column name"
  seller_id
  "column name"
  swap_id
  "column name"
  timestamp
  "column name"
  token_id
}

"column ordering options"
enum order_by {
  "in ascending order, nulls last"
  asc
  "in ascending order, nulls first"
  asc_nulls_first
  "in ascending order, nulls last"
  asc_nulls_last
  "in descending order, nulls first"
  desc
  "in descending order, nulls first"
  desc_nulls_first
  "in descending order, nulls last"
  desc_nulls_last
}

scalar bigint

scalar jsonb

scalar smallint

scalar timestamptz

"Boolean expression to compare columns of type \"Boolean\". All fields are combined with logical 'AND'."
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'."
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'."
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  "does the column match the given case-insensitive pattern"
  _ilike: String
  _in: [String!]
  "does the column match the given POSIX regular expression, case insensitive"
  _iregex: String
  _is_null: Boolean
  "does the column match the given pattern"
  _like: String
  _lt: String
  _lte: String
  _neq: String
  "does the column NOT match the given case-insensitive pattern"
  _nilike: String
  _nin: [String!]
  "does the column NOT match the given POSIX regular expression, case insensitive"
  _niregex: String
  "does the column NOT match the given pattern"
  _nlike: String
  "does the column NOT match the given POSIX regular expression, case sensitive"
  _nregex: String
  "does the column NOT match the given SQL regular expression"
  _nsimilar: String
  "does the column match the given POSIX regular expression, case sensitive"
  _regex: String
  "does the column match the given SQL regular expression"
  _similar: String
}

"Boolean expression to compare columns of type \"bigint\". All fields are combined with logical 'AND'."
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"order by aggregate values of table \"hic_et_nunc.ask\""
input hic_et_nunc_ask_aggregate_order_by {
  avg: hic_et_nunc_ask_avg_order_by
  count: order_by
  max: hic_et_nunc_ask_max_order_by
  min: hic_et_nunc_ask_min_order_by
  stddev: hic_et_nunc_ask_stddev_order_by
  stddev_pop: hic_et_nunc_ask_stddev_pop_order_by
  stddev_samp: hic_et_nunc_ask_stddev_samp_order_by
  sum: hic_et_nunc_ask_sum_order_by
  var_pop: hic_et_nunc_ask_var_pop_order_by
  var_samp: hic_et_nunc_ask_var_samp_order_by
  variance: hic_et_nunc_ask_variance_order_by
}

"order by avg() on columns of table \"hic_et_nunc.ask\""
input hic_et_nunc_ask_avg_order_by {
  amount: order_by
  amount_left: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  price: order_by
  royalties: order_by
  update_level: order_by
}

"Boolean expression to filter rows from the table \"hic_et_nunc.ask\". All fields are combined with a logical 'AND'."
input hic_et_nunc_ask_bool_exp {
  _and: [hic_et_nunc_ask_bool_exp!]
  _not: hic_et_nunc_ask_bool_exp
  _or: [hic_et_nunc_ask_bool_exp!]
  amount: bigint_comparison_exp
  amount_left: bigint_comparison_exp
  artist: holder_bool_exp
  artist_id: String_comparison_exp
  creator: holder_bool_exp
  creator_id: String_comparison_exp
  fa2: fa2_bool_exp
  fa2_id: String_comparison_exp
  fulfilled: hic_et_nunc_fulfilled_ask_bool_exp
  id: bigint_comparison_exp
  level: bigint_comparison_exp
  objkt_id: bigint_comparison_exp
  price: bigint_comparison_exp
  royalties: bigint_comparison_exp
  status: String_comparison_exp
  timestamp: timestamptz_comparison_exp
  update_level: bigint_comparison_exp
  update_timestamp: timestamptz_comparison_exp
}

"order by max() on columns of table \"hic_et_nunc.ask\""
input hic_et_nunc_ask_max_order_by {
  amount: order_by
  amount_left: order_by
  artist_id: order_by
  creator_id: order_by
  fa2_id: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  price: order_by
  royalties: order_by
  "ACTIVE: active\\nCANCELLED: cancelled\\nCONCLUDED: concluded"
  status: order_by
  timestamp: order_by
  update_level: order_by
  update_timestamp: order_by
}

"order by min() on columns of table \"hic_et_nunc.ask\""
input hic_et_nunc_ask_min_order_by {
  amount: order_by
  amount_left: order_by
  artist_id: order_by
  creator_id: order_by
  fa2_id: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  price: order_by
  royalties: order_by
  "ACTIVE: active\\nCANCELLED: cancelled\\nCONCLUDED: concluded"
  status: order_by
  timestamp: order_by
  update_level: order_by
  update_timestamp: order_by
}

"Ordering options when selecting data from \"hic_et_nunc.ask\"."
input hic_et_nunc_ask_order_by {
  amount: order_by
  amount_left: order_by
  artist: holder_order_by
  artist_id: order_by
  creator: holder_order_by
  creator_id: order_by
  fa2: fa2_order_by
  fa2_id: order_by
  fulfilled_aggregate: hic_et_nunc_fulfilled_ask_aggregate_order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  price: order_by
  royalties: order_by
  status: order_by
  timestamp: order_by
  update_level: order_by
  update_timestamp: order_by
}

"order by stddev() on columns of table \"hic_et_nunc.ask\""
input hic_et_nunc_ask_stddev_order_by {
  amount: order_by
  amount_left: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  price: order_by
  royalties: order_by
  update_level: order_by
}

"order by stddev_pop() on columns of table \"hic_et_nunc.ask\""
input hic_et_nunc_ask_stddev_pop_order_by {
  amount: order_by
  amount_left: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  price: order_by
  royalties: order_by
  update_level: order_by
}

"order by stddev_samp() on columns of table \"hic_et_nunc.ask\""
input hic_et_nunc_ask_stddev_samp_order_by {
  amount: order_by
  amount_left: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  price: order_by
  royalties: order_by
  update_level: order_by
}

"order by sum() on columns of table \"hic_et_nunc.ask\""
input hic_et_nunc_ask_sum_order_by {
  amount: order_by
  amount_left: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  price: order_by
  royalties: order_by
  update_level: order_by
}

"order by var_pop() on columns of table \"hic_et_nunc.ask\""
input hic_et_nunc_ask_var_pop_order_by {
  amount: order_by
  amount_left: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  price: order_by
  royalties: order_by
  update_level: order_by
}

"order by var_samp() on columns of table \"hic_et_nunc.ask\""
input hic_et_nunc_ask_var_samp_order_by {
  amount: order_by
  amount_left: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  price: order_by
  royalties: order_by
  update_level: order_by
}

"order by variance() on columns of table \"hic_et_nunc.ask\""
input hic_et_nunc_ask_variance_order_by {
  amount: order_by
  amount_left: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  price: order_by
  royalties: order_by
  update_level: order_by
}

"order by aggregate values of table \"hic_et_nunc.bid\""
input hic_et_nunc_bid_aggregate_order_by {
  avg: hic_et_nunc_bid_avg_order_by
  count: order_by
  max: hic_et_nunc_bid_max_order_by
  min: hic_et_nunc_bid_min_order_by
  stddev: hic_et_nunc_bid_stddev_order_by
  stddev_pop: hic_et_nunc_bid_stddev_pop_order_by
  stddev_samp: hic_et_nunc_bid_stddev_samp_order_by
  sum: hic_et_nunc_bid_sum_order_by
  var_pop: hic_et_nunc_bid_var_pop_order_by
  var_samp: hic_et_nunc_bid_var_samp_order_by
  variance: hic_et_nunc_bid_variance_order_by
}

"order by avg() on columns of table \"hic_et_nunc.bid\""
input hic_et_nunc_bid_avg_order_by {
  id: order_by
  level: order_by
  objkt_id: order_by
  price: order_by
  royalties: order_by
  update_level: order_by
}

"Boolean expression to filter rows from the table \"hic_et_nunc.bid\". All fields are combined with a logical 'AND'."
input hic_et_nunc_bid_bool_exp {
  _and: [hic_et_nunc_bid_bool_exp!]
  _not: hic_et_nunc_bid_bool_exp
  _or: [hic_et_nunc_bid_bool_exp!]
  artist: holder_bool_exp
  artist_id: String_comparison_exp
  creator: holder_bool_exp
  creator_id: String_comparison_exp
  fa2: fa2_bool_exp
  fa2_id: String_comparison_exp
  id: bigint_comparison_exp
  level: bigint_comparison_exp
  objkt_id: bigint_comparison_exp
  price: bigint_comparison_exp
  royalties: bigint_comparison_exp
  seller: holder_bool_exp
  seller_id: String_comparison_exp
  status: String_comparison_exp
  timestamp: timestamptz_comparison_exp
  update_level: bigint_comparison_exp
  update_timestamp: timestamptz_comparison_exp
}

"order by max() on columns of table \"hic_et_nunc.bid\""
input hic_et_nunc_bid_max_order_by {
  artist_id: order_by
  creator_id: order_by
  fa2_id: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  price: order_by
  royalties: order_by
  seller_id: order_by
  "ACTIVE: active\\nCANCELLED: cancelled\\nCONCLUDED: concluded"
  status: order_by
  timestamp: order_by
  update_level: order_by
  update_timestamp: order_by
}

"order by min() on columns of table \"hic_et_nunc.bid\""
input hic_et_nunc_bid_min_order_by {
  artist_id: order_by
  creator_id: order_by
  fa2_id: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  price: order_by
  royalties: order_by
  seller_id: order_by
  "ACTIVE: active\\nCANCELLED: cancelled\\nCONCLUDED: concluded"
  status: order_by
  timestamp: order_by
  update_level: order_by
  update_timestamp: order_by
}

"Ordering options when selecting data from \"hic_et_nunc.bid\"."
input hic_et_nunc_bid_order_by {
  artist: holder_order_by
  artist_id: order_by
  creator: holder_order_by
  creator_id: order_by
  fa2: fa2_order_by
  fa2_id: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  price: order_by
  royalties: order_by
  seller: holder_order_by
  seller_id: order_by
  status: order_by
  timestamp: order_by
  update_level: order_by
  update_timestamp: order_by
}

"order by stddev() on columns of table \"hic_et_nunc.bid\""
input hic_et_nunc_bid_stddev_order_by {
  id: order_by
  level: order_by
  objkt_id: order_by
  price: order_by
  royalties: order_by
  update_level: order_by
}

"order by stddev_pop() on columns of table \"hic_et_nunc.bid\""
input hic_et_nunc_bid_stddev_pop_order_by {
  id: order_by
  level: order_by
  objkt_id: order_by
  price: order_by
  royalties: order_by
  update_level: order_by
}

"order by stddev_samp() on columns of table \"hic_et_nunc.bid\""
input hic_et_nunc_bid_stddev_samp_order_by {
  id: order_by
  level: order_by
  objkt_id: order_by
  price: order_by
  royalties: order_by
  update_level: order_by
}

"order by sum() on columns of table \"hic_et_nunc.bid\""
input hic_et_nunc_bid_sum_order_by {
  id: order_by
  level: order_by
  objkt_id: order_by
  price: order_by
  royalties: order_by
  update_level: order_by
}

"order by var_pop() on columns of table \"hic_et_nunc.bid\""
input hic_et_nunc_bid_var_pop_order_by {
  id: order_by
  level: order_by
  objkt_id: order_by
  price: order_by
  royalties: order_by
  update_level: order_by
}

"order by var_samp() on columns of table \"hic_et_nunc.bid\""
input hic_et_nunc_bid_var_samp_order_by {
  id: order_by
  level: order_by
  objkt_id: order_by
  price: order_by
  royalties: order_by
  update_level: order_by
}

"order by variance() on columns of table \"hic_et_nunc.bid\""
input hic_et_nunc_bid_variance_order_by {
  id: order_by
  level: order_by
  objkt_id: order_by
  price: order_by
  royalties: order_by
  update_level: order_by
}

"Boolean expression to filter rows from the table \"hic_et_nunc.dipdup_state\". All fields are combined with a logical 'AND'."
input dipdup_index_bool_exp {
  _and: [dipdup_index_bool_exp!]
  _not: dipdup_index_bool_exp
  _or: [dipdup_index_bool_exp!]
  hash: String_comparison_exp
  index_hash: String_comparison_exp
  index_name: String_comparison_exp
  index_type: String_comparison_exp
  level: Int_comparison_exp
}

"Ordering options when selecting data from \"hic_et_nunc.dipdup_state\"."
input dipdup_index_order_by {
  hash: order_by
  index_hash: order_by
  index_name: order_by
  index_type: order_by
  level: order_by
}

"order by aggregate values of table \"hic_et_nunc.dutch_auction\""
input hic_et_nunc_dutch_auction_aggregate_order_by {
  avg: hic_et_nunc_dutch_auction_avg_order_by
  count: order_by
  max: hic_et_nunc_dutch_auction_max_order_by
  min: hic_et_nunc_dutch_auction_min_order_by
  stddev: hic_et_nunc_dutch_auction_stddev_order_by
  stddev_pop: hic_et_nunc_dutch_auction_stddev_pop_order_by
  stddev_samp: hic_et_nunc_dutch_auction_stddev_samp_order_by
  sum: hic_et_nunc_dutch_auction_sum_order_by
  var_pop: hic_et_nunc_dutch_auction_var_pop_order_by
  var_samp: hic_et_nunc_dutch_auction_var_samp_order_by
  variance: hic_et_nunc_dutch_auction_variance_order_by
}

"order by avg() on columns of table \"hic_et_nunc.dutch_auction\""
input hic_et_nunc_dutch_auction_avg_order_by {
  buy_price: order_by
  contract_version: order_by
  end_price: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  royalties: order_by
  start_price: order_by
  update_level: order_by
}

"Boolean expression to filter rows from the table \"hic_et_nunc.dutch_auction\". All fields are combined with a logical 'AND'."
input hic_et_nunc_dutch_auction_bool_exp {
  _and: [hic_et_nunc_dutch_auction_bool_exp!]
  _not: hic_et_nunc_dutch_auction_bool_exp
  _or: [hic_et_nunc_dutch_auction_bool_exp!]
  artist: holder_bool_exp
  artist_id: String_comparison_exp
  buy_price: bigint_comparison_exp
  buyer: holder_bool_exp
  buyer_id: String_comparison_exp
  contract_version: smallint_comparison_exp
  creator: holder_bool_exp
  creator_id: String_comparison_exp
  end_price: bigint_comparison_exp
  end_time: timestamptz_comparison_exp
  fa2: fa2_bool_exp
  fa2_id: String_comparison_exp
  hash: String_comparison_exp
  id: bigint_comparison_exp
  level: bigint_comparison_exp
  objkt_id: bigint_comparison_exp
  royalties: bigint_comparison_exp
  start_price: bigint_comparison_exp
  start_time: timestamptz_comparison_exp
  status: String_comparison_exp
  timestamp: timestamptz_comparison_exp
  update_level: bigint_comparison_exp
  update_timestamp: timestamptz_comparison_exp
}

"order by max() on columns of table \"hic_et_nunc.dutch_auction\""
input hic_et_nunc_dutch_auction_max_order_by {
  artist_id: order_by
  buy_price: order_by
  buyer_id: order_by
  contract_version: order_by
  creator_id: order_by
  end_price: order_by
  end_time: order_by
  fa2_id: order_by
  hash: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  royalties: order_by
  start_price: order_by
  start_time: order_by
  "ACTIVE: active\\nCANCELLED: cancelled\\nCONCLUDED: concluded"
  status: order_by
  timestamp: order_by
  update_level: order_by
  update_timestamp: order_by
}

"order by min() on columns of table \"hic_et_nunc.dutch_auction\""
input hic_et_nunc_dutch_auction_min_order_by {
  artist_id: order_by
  buy_price: order_by
  buyer_id: order_by
  contract_version: order_by
  creator_id: order_by
  end_price: order_by
  end_time: order_by
  fa2_id: order_by
  hash: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  royalties: order_by
  start_price: order_by
  start_time: order_by
  "ACTIVE: active\\nCANCELLED: cancelled\\nCONCLUDED: concluded"
  status: order_by
  timestamp: order_by
  update_level: order_by
  update_timestamp: order_by
}

"Ordering options when selecting data from \"hic_et_nunc.dutch_auction\"."
input hic_et_nunc_dutch_auction_order_by {
  artist: holder_order_by
  artist_id: order_by
  buy_price: order_by
  buyer: holder_order_by
  buyer_id: order_by
  contract_version: order_by
  creator: holder_order_by
  creator_id: order_by
  end_price: order_by
  end_time: order_by
  fa2: fa2_order_by
  fa2_id: order_by
  hash: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  royalties: order_by
  start_price: order_by
  start_time: order_by
  status: order_by
  timestamp: order_by
  update_level: order_by
  update_timestamp: order_by
}

"order by stddev() on columns of table \"hic_et_nunc.dutch_auction\""
input hic_et_nunc_dutch_auction_stddev_order_by {
  buy_price: order_by
  contract_version: order_by
  end_price: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  royalties: order_by
  start_price: order_by
  update_level: order_by
}

"order by stddev_pop() on columns of table \"hic_et_nunc.dutch_auction\""
input hic_et_nunc_dutch_auction_stddev_pop_order_by {
  buy_price: order_by
  contract_version: order_by
  end_price: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  royalties: order_by
  start_price: order_by
  update_level: order_by
}

"order by stddev_samp() on columns of table \"hic_et_nunc.dutch_auction\""
input hic_et_nunc_dutch_auction_stddev_samp_order_by {
  buy_price: order_by
  contract_version: order_by
  end_price: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  royalties: order_by
  start_price: order_by
  update_level: order_by
}

"order by sum() on columns of table \"hic_et_nunc.dutch_auction\""
input hic_et_nunc_dutch_auction_sum_order_by {
  buy_price: order_by
  contract_version: order_by
  end_price: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  royalties: order_by
  start_price: order_by
  update_level: order_by
}

"order by var_pop() on columns of table \"hic_et_nunc.dutch_auction\""
input hic_et_nunc_dutch_auction_var_pop_order_by {
  buy_price: order_by
  contract_version: order_by
  end_price: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  royalties: order_by
  start_price: order_by
  update_level: order_by
}

"order by var_samp() on columns of table \"hic_et_nunc.dutch_auction\""
input hic_et_nunc_dutch_auction_var_samp_order_by {
  buy_price: order_by
  contract_version: order_by
  end_price: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  royalties: order_by
  start_price: order_by
  update_level: order_by
}

"order by variance() on columns of table \"hic_et_nunc.dutch_auction\""
input hic_et_nunc_dutch_auction_variance_order_by {
  buy_price: order_by
  contract_version: order_by
  end_price: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  royalties: order_by
  start_price: order_by
  update_level: order_by
}

"order by aggregate values of table \"hic_et_nunc.english_auction\""
input hic_et_nunc_english_auction_aggregate_order_by {
  avg: hic_et_nunc_english_auction_avg_order_by
  count: order_by
  max: hic_et_nunc_english_auction_max_order_by
  min: hic_et_nunc_english_auction_min_order_by
  stddev: hic_et_nunc_english_auction_stddev_order_by
  stddev_pop: hic_et_nunc_english_auction_stddev_pop_order_by
  stddev_samp: hic_et_nunc_english_auction_stddev_samp_order_by
  sum: hic_et_nunc_english_auction_sum_order_by
  var_pop: hic_et_nunc_english_auction_var_pop_order_by
  var_samp: hic_et_nunc_english_auction_var_samp_order_by
  variance: hic_et_nunc_english_auction_variance_order_by
}

"order by avg() on columns of table \"hic_et_nunc.english_auction\""
input hic_et_nunc_english_auction_avg_order_by {
  contract_version: order_by
  extension_time: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  price_increment: order_by
  reserve: order_by
  royalties: order_by
  update_level: order_by
}

"Boolean expression to filter rows from the table \"hic_et_nunc.english_auction\". All fields are combined with a logical 'AND'."
input hic_et_nunc_english_auction_bool_exp {
  _and: [hic_et_nunc_english_auction_bool_exp!]
  _not: hic_et_nunc_english_auction_bool_exp
  _or: [hic_et_nunc_english_auction_bool_exp!]
  artist: holder_bool_exp
  artist_id: String_comparison_exp
  bids: hic_et_nunc_english_bid_bool_exp
  contract_version: smallint_comparison_exp
  creator: holder_bool_exp
  creator_id: String_comparison_exp
  end_time: timestamptz_comparison_exp
  extension_time: bigint_comparison_exp
  fa2: fa2_bool_exp
  fa2_id: String_comparison_exp
  hash: String_comparison_exp
  id: bigint_comparison_exp
  level: bigint_comparison_exp
  objkt_id: bigint_comparison_exp
  price_increment: bigint_comparison_exp
  reserve: bigint_comparison_exp
  royalties: bigint_comparison_exp
  start_time: timestamptz_comparison_exp
  status: String_comparison_exp
  timestamp: timestamptz_comparison_exp
  update_level: bigint_comparison_exp
  update_timestamp: timestamptz_comparison_exp
}

"order by max() on columns of table \"hic_et_nunc.english_auction\""
input hic_et_nunc_english_auction_max_order_by {
  artist_id: order_by
  contract_version: order_by
  creator_id: order_by
  end_time: order_by
  extension_time: order_by
  fa2_id: order_by
  hash: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  price_increment: order_by
  reserve: order_by
  royalties: order_by
  start_time: order_by
  "ACTIVE: active\\nCANCELLED: cancelled\\nCONCLUDED: concluded"
  status: order_by
  timestamp: order_by
  update_level: order_by
  update_timestamp: order_by
}

"order by min() on columns of table \"hic_et_nunc.english_auction\""
input hic_et_nunc_english_auction_min_order_by {
  artist_id: order_by
  contract_version: order_by
  creator_id: order_by
  end_time: order_by
  extension_time: order_by
  fa2_id: order_by
  hash: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  price_increment: order_by
  reserve: order_by
  royalties: order_by
  start_time: order_by
  "ACTIVE: active\\nCANCELLED: cancelled\\nCONCLUDED: concluded"
  status: order_by
  timestamp: order_by
  update_level: order_by
  update_timestamp: order_by
}

"Ordering options when selecting data from \"hic_et_nunc.english_auction\"."
input hic_et_nunc_english_auction_order_by {
  artist: holder_order_by
  artist_id: order_by
  bids_aggregate: hic_et_nunc_english_bid_aggregate_order_by
  contract_version: order_by
  creator: holder_order_by
  creator_id: order_by
  end_time: order_by
  extension_time: order_by
  fa2: fa2_order_by
  fa2_id: order_by
  hash: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  price_increment: order_by
  reserve: order_by
  royalties: order_by
  start_time: order_by
  status: order_by
  timestamp: order_by
  update_level: order_by
  update_timestamp: order_by
}

"order by stddev() on columns of table \"hic_et_nunc.english_auction\""
input hic_et_nunc_english_auction_stddev_order_by {
  contract_version: order_by
  extension_time: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  price_increment: order_by
  reserve: order_by
  royalties: order_by
  update_level: order_by
}

"order by stddev_pop() on columns of table \"hic_et_nunc.english_auction\""
input hic_et_nunc_english_auction_stddev_pop_order_by {
  contract_version: order_by
  extension_time: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  price_increment: order_by
  reserve: order_by
  royalties: order_by
  update_level: order_by
}

"order by stddev_samp() on columns of table \"hic_et_nunc.english_auction\""
input hic_et_nunc_english_auction_stddev_samp_order_by {
  contract_version: order_by
  extension_time: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  price_increment: order_by
  reserve: order_by
  royalties: order_by
  update_level: order_by
}

"order by sum() on columns of table \"hic_et_nunc.english_auction\""
input hic_et_nunc_english_auction_sum_order_by {
  contract_version: order_by
  extension_time: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  price_increment: order_by
  reserve: order_by
  royalties: order_by
  update_level: order_by
}

"order by var_pop() on columns of table \"hic_et_nunc.english_auction\""
input hic_et_nunc_english_auction_var_pop_order_by {
  contract_version: order_by
  extension_time: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  price_increment: order_by
  reserve: order_by
  royalties: order_by
  update_level: order_by
}

"order by var_samp() on columns of table \"hic_et_nunc.english_auction\""
input hic_et_nunc_english_auction_var_samp_order_by {
  contract_version: order_by
  extension_time: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  price_increment: order_by
  reserve: order_by
  royalties: order_by
  update_level: order_by
}

"order by variance() on columns of table \"hic_et_nunc.english_auction\""
input hic_et_nunc_english_auction_variance_order_by {
  contract_version: order_by
  extension_time: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  price_increment: order_by
  reserve: order_by
  royalties: order_by
  update_level: order_by
}

"order by aggregate values of table \"hic_et_nunc.english_bid\""
input hic_et_nunc_english_bid_aggregate_order_by {
  avg: hic_et_nunc_english_bid_avg_order_by
  count: order_by
  max: hic_et_nunc_english_bid_max_order_by
  min: hic_et_nunc_english_bid_min_order_by
  stddev: hic_et_nunc_english_bid_stddev_order_by
  stddev_pop: hic_et_nunc_english_bid_stddev_pop_order_by
  stddev_samp: hic_et_nunc_english_bid_stddev_samp_order_by
  sum: hic_et_nunc_english_bid_sum_order_by
  var_pop: hic_et_nunc_english_bid_var_pop_order_by
  var_samp: hic_et_nunc_english_bid_var_samp_order_by
  variance: hic_et_nunc_english_bid_variance_order_by
}

"order by avg() on columns of table \"hic_et_nunc.english_bid\""
input hic_et_nunc_english_bid_avg_order_by {
  amount: order_by
  auction_id: order_by
  id: order_by
  level: order_by
}

"Boolean expression to filter rows from the table \"hic_et_nunc.english_bid\". All fields are combined with a logical 'AND'."
input hic_et_nunc_english_bid_bool_exp {
  _and: [hic_et_nunc_english_bid_bool_exp!]
  _not: hic_et_nunc_english_bid_bool_exp
  _or: [hic_et_nunc_english_bid_bool_exp!]
  amount: bigint_comparison_exp
  auction: hic_et_nunc_english_auction_bool_exp
  auction_id: bigint_comparison_exp
  bidder: holder_bool_exp
  bidder_id: String_comparison_exp
  id: bigint_comparison_exp
  level: bigint_comparison_exp
  timestamp: timestamptz_comparison_exp
}

"order by max() on columns of table \"hic_et_nunc.english_bid\""
input hic_et_nunc_english_bid_max_order_by {
  amount: order_by
  auction_id: order_by
  bidder_id: order_by
  id: order_by
  level: order_by
  timestamp: order_by
}

"order by min() on columns of table \"hic_et_nunc.english_bid\""
input hic_et_nunc_english_bid_min_order_by {
  amount: order_by
  auction_id: order_by
  bidder_id: order_by
  id: order_by
  level: order_by
  timestamp: order_by
}

"Ordering options when selecting data from \"hic_et_nunc.english_bid\"."
input hic_et_nunc_english_bid_order_by {
  amount: order_by
  auction: hic_et_nunc_english_auction_order_by
  auction_id: order_by
  bidder: holder_order_by
  bidder_id: order_by
  id: order_by
  level: order_by
  timestamp: order_by
}

"order by stddev() on columns of table \"hic_et_nunc.english_bid\""
input hic_et_nunc_english_bid_stddev_order_by {
  amount: order_by
  auction_id: order_by
  id: order_by
  level: order_by
}

"order by stddev_pop() on columns of table \"hic_et_nunc.english_bid\""
input hic_et_nunc_english_bid_stddev_pop_order_by {
  amount: order_by
  auction_id: order_by
  id: order_by
  level: order_by
}

"order by stddev_samp() on columns of table \"hic_et_nunc.english_bid\""
input hic_et_nunc_english_bid_stddev_samp_order_by {
  amount: order_by
  auction_id: order_by
  id: order_by
  level: order_by
}

"order by sum() on columns of table \"hic_et_nunc.english_bid\""
input hic_et_nunc_english_bid_sum_order_by {
  amount: order_by
  auction_id: order_by
  id: order_by
  level: order_by
}

"order by var_pop() on columns of table \"hic_et_nunc.english_bid\""
input hic_et_nunc_english_bid_var_pop_order_by {
  amount: order_by
  auction_id: order_by
  id: order_by
  level: order_by
}

"order by var_samp() on columns of table \"hic_et_nunc.english_bid\""
input hic_et_nunc_english_bid_var_samp_order_by {
  amount: order_by
  auction_id: order_by
  id: order_by
  level: order_by
}

"order by variance() on columns of table \"hic_et_nunc.english_bid\""
input hic_et_nunc_english_bid_variance_order_by {
  amount: order_by
  auction_id: order_by
  id: order_by
  level: order_by
}

"Boolean expression to filter rows from the table \"hic_et_nunc.fa2\". All fields are combined with a logical 'AND'."
input fa2_bool_exp {
  _and: [fa2_bool_exp!]
  _not: fa2_bool_exp
  _or: [fa2_bool_exp!]
  asks: hic_et_nunc_ask_bool_exp
  bids: hic_et_nunc_bid_bool_exp
  contract: String_comparison_exp
  dutch_auctions: hic_et_nunc_dutch_auction_bool_exp
  english_auctions: hic_et_nunc_english_auction_bool_exp
  swaps: swap_bool_exp
}

"Ordering options when selecting data from \"hic_et_nunc.fa2\"."
input fa2_order_by {
  asks_aggregate: hic_et_nunc_ask_aggregate_order_by
  bids_aggregate: hic_et_nunc_bid_aggregate_order_by
  contract: order_by
  dutch_auctions_aggregate: hic_et_nunc_dutch_auction_aggregate_order_by
  english_auctions_aggregate: hic_et_nunc_english_auction_aggregate_order_by
  swaps_aggregate: swap_aggregate_order_by
}

"order by aggregate values of table \"hic_et_nunc.fulfilled_ask\""
input hic_et_nunc_fulfilled_ask_aggregate_order_by {
  avg: hic_et_nunc_fulfilled_ask_avg_order_by
  count: order_by
  max: hic_et_nunc_fulfilled_ask_max_order_by
  min: hic_et_nunc_fulfilled_ask_min_order_by
  stddev: hic_et_nunc_fulfilled_ask_stddev_order_by
  stddev_pop: hic_et_nunc_fulfilled_ask_stddev_pop_order_by
  stddev_samp: hic_et_nunc_fulfilled_ask_stddev_samp_order_by
  sum: hic_et_nunc_fulfilled_ask_sum_order_by
  var_pop: hic_et_nunc_fulfilled_ask_var_pop_order_by
  var_samp: hic_et_nunc_fulfilled_ask_var_samp_order_by
  variance: hic_et_nunc_fulfilled_ask_variance_order_by
}

"order by avg() on columns of table \"hic_et_nunc.fulfilled_ask\""
input hic_et_nunc_fulfilled_ask_avg_order_by {
  amount: order_by
  ask_id: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
}

"Boolean expression to filter rows from the table \"hic_et_nunc.fulfilled_ask\". All fields are combined with a logical 'AND'."
input hic_et_nunc_fulfilled_ask_bool_exp {
  _and: [hic_et_nunc_fulfilled_ask_bool_exp!]
  _not: hic_et_nunc_fulfilled_ask_bool_exp
  _or: [hic_et_nunc_fulfilled_ask_bool_exp!]
  amount: bigint_comparison_exp
  ask: hic_et_nunc_ask_bool_exp
  ask_id: bigint_comparison_exp
  buyer: holder_bool_exp
  buyer_id: String_comparison_exp
  id: bigint_comparison_exp
  level: bigint_comparison_exp
  objkt_id: bigint_comparison_exp
  seller: holder_bool_exp
  seller_id: String_comparison_exp
  timestamp: timestamptz_comparison_exp
}

"order by max() on columns of table \"hic_et_nunc.fulfilled_ask\""
input hic_et_nunc_fulfilled_ask_max_order_by {
  amount: order_by
  ask_id: order_by
  buyer_id: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  seller_id: order_by
  timestamp: order_by
}

"order by min() on columns of table \"hic_et_nunc.fulfilled_ask\""
input hic_et_nunc_fulfilled_ask_min_order_by {
  amount: order_by
  ask_id: order_by
  buyer_id: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  seller_id: order_by
  timestamp: order_by
}

"Ordering options when selecting data from \"hic_et_nunc.fulfilled_ask\"."
input hic_et_nunc_fulfilled_ask_order_by {
  amount: order_by
  ask: hic_et_nunc_ask_order_by
  ask_id: order_by
  buyer: holder_order_by
  buyer_id: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
  seller: holder_order_by
  seller_id: order_by
  timestamp: order_by
}

"order by stddev() on columns of table \"hic_et_nunc.fulfilled_ask\""
input hic_et_nunc_fulfilled_ask_stddev_order_by {
  amount: order_by
  ask_id: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
}

"order by stddev_pop() on columns of table \"hic_et_nunc.fulfilled_ask\""
input hic_et_nunc_fulfilled_ask_stddev_pop_order_by {
  amount: order_by
  ask_id: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
}

"order by stddev_samp() on columns of table \"hic_et_nunc.fulfilled_ask\""
input hic_et_nunc_fulfilled_ask_stddev_samp_order_by {
  amount: order_by
  ask_id: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
}

"order by sum() on columns of table \"hic_et_nunc.fulfilled_ask\""
input hic_et_nunc_fulfilled_ask_sum_order_by {
  amount: order_by
  ask_id: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
}

"order by var_pop() on columns of table \"hic_et_nunc.fulfilled_ask\""
input hic_et_nunc_fulfilled_ask_var_pop_order_by {
  amount: order_by
  ask_id: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
}

"order by var_samp() on columns of table \"hic_et_nunc.fulfilled_ask\""
input hic_et_nunc_fulfilled_ask_var_samp_order_by {
  amount: order_by
  ask_id: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
}

"order by variance() on columns of table \"hic_et_nunc.fulfilled_ask\""
input hic_et_nunc_fulfilled_ask_variance_order_by {
  amount: order_by
  ask_id: order_by
  id: order_by
  level: order_by
  objkt_id: order_by
}

"Boolean expression to filter rows from the table \"hic_et_nunc.holder\". All fields are combined with a logical 'AND'."
input holder_bool_exp {
  _and: [holder_bool_exp!]
  _not: holder_bool_exp
  _or: [holder_bool_exp!]
  address: String_comparison_exp
  asks: hic_et_nunc_ask_bool_exp
  bids: hic_et_nunc_bid_bool_exp
  bought_asks: hic_et_nunc_fulfilled_ask_bool_exp
  created_dutch_auctions: hic_et_nunc_dutch_auction_bool_exp
  created_english_auctions: hic_et_nunc_english_auction_bool_exp
  description: String_comparison_exp
  english_bids: hic_et_nunc_english_bid_bool_exp
  hdao_balance: bigint_comparison_exp
  holder_signatures: hic_et_nunc_split_signatures_bool_exp
  holders_token: token_holder_bool_exp
  is_split: Boolean_comparison_exp
  metadata: jsonb_comparison_exp
  metadata_file: String_comparison_exp
  name: String_comparison_exp
  owner: token_operator_bool_exp
  purchases: trade_bool_exp
  sales: trade_bool_exp
  shareholder: shareholder_bool_exp
  shares: splitcontract_bool_exp
  sold_asks: hic_et_nunc_fulfilled_ask_bool_exp
  sold_bids: hic_et_nunc_bid_bool_exp
  starring_asks: hic_et_nunc_ask_bool_exp
  starring_bids: hic_et_nunc_bid_bool_exp
  starring_dutch_auctions: hic_et_nunc_dutch_auction_bool_exp
  starring_english_auctions: hic_et_nunc_english_auction_bool_exp
  swaps: swap_bool_exp
  tokens: token_bool_exp
  won_dutch_auctions: hic_et_nunc_dutch_auction_bool_exp
}

"Ordering options when selecting data from \"hic_et_nunc.holder\"."
input holder_order_by {
  address: order_by
  asks_aggregate: hic_et_nunc_ask_aggregate_order_by
  bids_aggregate: hic_et_nunc_bid_aggregate_order_by
  bought_asks_aggregate: hic_et_nunc_fulfilled_ask_aggregate_order_by
  created_dutch_auctions_aggregate: hic_et_nunc_dutch_auction_aggregate_order_by
  created_english_auctions_aggregate: hic_et_nunc_english_auction_aggregate_order_by
  description: order_by
  english_bids_aggregate: hic_et_nunc_english_bid_aggregate_order_by
  hdao_balance: order_by
  holder_signatures_aggregate: hic_et_nunc_split_signatures_aggregate_order_by
  holders_token_aggregate: token_holder_aggregate_order_by
  is_split: order_by
  metadata: order_by
  metadata_file: order_by
  name: order_by
  owner_aggregate: token_operator_aggregate_order_by
  purchases_aggregate: trade_aggregate_order_by
  sales_aggregate: trade_aggregate_order_by
  shareholder_aggregate: shareholder_aggregate_order_by
  shares_aggregate: splitcontract_aggregate_order_by
  sold_asks_aggregate: hic_et_nunc_fulfilled_ask_aggregate_order_by
  sold_bids_aggregate: hic_et_nunc_bid_aggregate_order_by
  starring_asks_aggregate: hic_et_nunc_ask_aggregate_order_by
  starring_bids_aggregate: hic_et_nunc_bid_aggregate_order_by
  starring_dutch_auctions_aggregate: hic_et_nunc_dutch_auction_aggregate_order_by
  starring_english_auctions_aggregate: hic_et_nunc_english_auction_aggregate_order_by
  swaps_aggregate: swap_aggregate_order_by
  tokens_aggregate: token_aggregate_order_by
  won_dutch_auctions_aggregate: hic_et_nunc_dutch_auction_aggregate_order_by
}

"order by aggregate values of table \"hic_et_nunc.shareholder\""
input shareholder_aggregate_order_by {
  avg: shareholder_avg_order_by
  count: order_by
  max: shareholder_max_order_by
  min: shareholder_min_order_by
  stddev: shareholder_stddev_order_by
  stddev_pop: shareholder_stddev_pop_order_by
  stddev_samp: shareholder_stddev_samp_order_by
  sum: shareholder_sum_order_by
  var_pop: shareholder_var_pop_order_by
  var_samp: shareholder_var_samp_order_by
  variance: shareholder_variance_order_by
}

"order by avg() on columns of table \"hic_et_nunc.shareholder\""
input shareholder_avg_order_by {
  id: order_by
  shares: order_by
  split_contract_id: order_by
}

"Boolean expression to filter rows from the table \"hic_et_nunc.shareholder\". All fields are combined with a logical 'AND'."
input shareholder_bool_exp {
  _and: [shareholder_bool_exp!]
  _not: shareholder_bool_exp
  _or: [shareholder_bool_exp!]
  holder: holder_bool_exp
  holder_id: String_comparison_exp
  holder_type: String_comparison_exp
  id: Int_comparison_exp
  shares: bigint_comparison_exp
  split_contract: splitcontract_bool_exp
  split_contract_id: Int_comparison_exp
}

"order by max() on columns of table \"hic_et_nunc.shareholder\""
input shareholder_max_order_by {
  holder_id: order_by
  "unspecified: unspecified\\ncore_participant: core_participant\\nbenefactor: benefactor"
  holder_type: order_by
  id: order_by
  shares: order_by
  split_contract_id: order_by
}

"order by min() on columns of table \"hic_et_nunc.shareholder\""
input shareholder_min_order_by {
  holder_id: order_by
  "unspecified: unspecified\\ncore_participant: core_participant\\nbenefactor: benefactor"
  holder_type: order_by
  id: order_by
  shares: order_by
  split_contract_id: order_by
}

"Ordering options when selecting data from \"hic_et_nunc.shareholder\"."
input shareholder_order_by {
  holder: holder_order_by
  holder_id: order_by
  holder_type: order_by
  id: order_by
  shares: order_by
  split_contract: splitcontract_order_by
  split_contract_id: order_by
}

"order by stddev() on columns of table \"hic_et_nunc.shareholder\""
input shareholder_stddev_order_by {
  id: order_by
  shares: order_by
  split_contract_id: order_by
}

"order by stddev_pop() on columns of table \"hic_et_nunc.shareholder\""
input shareholder_stddev_pop_order_by {
  id: order_by
  shares: order_by
  split_contract_id: order_by
}

"order by stddev_samp() on columns of table \"hic_et_nunc.shareholder\""
input shareholder_stddev_samp_order_by {
  id: order_by
  shares: order_by
  split_contract_id: order_by
}

"order by sum() on columns of table \"hic_et_nunc.shareholder\""
input shareholder_sum_order_by {
  id: order_by
  shares: order_by
  split_contract_id: order_by
}

"order by var_pop() on columns of table \"hic_et_nunc.shareholder\""
input shareholder_var_pop_order_by {
  id: order_by
  shares: order_by
  split_contract_id: order_by
}

"order by var_samp() on columns of table \"hic_et_nunc.shareholder\""
input shareholder_var_samp_order_by {
  id: order_by
  shares: order_by
  split_contract_id: order_by
}

"order by variance() on columns of table \"hic_et_nunc.shareholder\""
input shareholder_variance_order_by {
  id: order_by
  shares: order_by
  split_contract_id: order_by
}

"order by aggregate values of table \"hic_et_nunc.split_signatures\""
input hic_et_nunc_split_signatures_aggregate_order_by {
  avg: hic_et_nunc_split_signatures_avg_order_by
  count: order_by
  max: hic_et_nunc_split_signatures_max_order_by
  min: hic_et_nunc_split_signatures_min_order_by
  stddev: hic_et_nunc_split_signatures_stddev_order_by
  stddev_pop: hic_et_nunc_split_signatures_stddev_pop_order_by
  stddev_samp: hic_et_nunc_split_signatures_stddev_samp_order_by
  sum: hic_et_nunc_split_signatures_sum_order_by
  var_pop: hic_et_nunc_split_signatures_var_pop_order_by
  var_samp: hic_et_nunc_split_signatures_var_samp_order_by
  variance: hic_et_nunc_split_signatures_variance_order_by
}

"order by avg() on columns of table \"hic_et_nunc.split_signatures\""
input hic_et_nunc_split_signatures_avg_order_by {
  id: order_by
  token_id: order_by
}

"Boolean expression to filter rows from the table \"hic_et_nunc.split_signatures\". All fields are combined with a logical 'AND'."
input hic_et_nunc_split_signatures_bool_exp {
  _and: [hic_et_nunc_split_signatures_bool_exp!]
  _not: hic_et_nunc_split_signatures_bool_exp
  _or: [hic_et_nunc_split_signatures_bool_exp!]
  holder: holder_bool_exp
  holder_id: String_comparison_exp
  id: Int_comparison_exp
  token: token_bool_exp
  token_id: bigint_comparison_exp
}

"order by max() on columns of table \"hic_et_nunc.split_signatures\""
input hic_et_nunc_split_signatures_max_order_by {
  holder_id: order_by
  id: order_by
  token_id: order_by
}

"order by min() on columns of table \"hic_et_nunc.split_signatures\""
input hic_et_nunc_split_signatures_min_order_by {
  holder_id: order_by
  id: order_by
  token_id: order_by
}

"Ordering options when selecting data from \"hic_et_nunc.split_signatures\"."
input hic_et_nunc_split_signatures_order_by {
  holder: holder_order_by
  holder_id: order_by
  id: order_by
  token: token_order_by
  token_id: order_by
}

"order by stddev() on columns of table \"hic_et_nunc.split_signatures\""
input hic_et_nunc_split_signatures_stddev_order_by {
  id: order_by
  token_id: order_by
}

"order by stddev_pop() on columns of table \"hic_et_nunc.split_signatures\""
input hic_et_nunc_split_signatures_stddev_pop_order_by {
  id: order_by
  token_id: order_by
}

"order by stddev_samp() on columns of table \"hic_et_nunc.split_signatures\""
input hic_et_nunc_split_signatures_stddev_samp_order_by {
  id: order_by
  token_id: order_by
}

"order by sum() on columns of table \"hic_et_nunc.split_signatures\""
input hic_et_nunc_split_signatures_sum_order_by {
  id: order_by
  token_id: order_by
}

"order by var_pop() on columns of table \"hic_et_nunc.split_signatures\""
input hic_et_nunc_split_signatures_var_pop_order_by {
  id: order_by
  token_id: order_by
}

"order by var_samp() on columns of table \"hic_et_nunc.split_signatures\""
input hic_et_nunc_split_signatures_var_samp_order_by {
  id: order_by
  token_id: order_by
}

"order by variance() on columns of table \"hic_et_nunc.split_signatures\""
input hic_et_nunc_split_signatures_variance_order_by {
  id: order_by
  token_id: order_by
}

"order by aggregate values of table \"hic_et_nunc.splitcontract\""
input splitcontract_aggregate_order_by {
  avg: splitcontract_avg_order_by
  count: order_by
  max: splitcontract_max_order_by
  min: splitcontract_min_order_by
  stddev: splitcontract_stddev_order_by
  stddev_pop: splitcontract_stddev_pop_order_by
  stddev_samp: splitcontract_stddev_samp_order_by
  sum: splitcontract_sum_order_by
  var_pop: splitcontract_var_pop_order_by
  var_samp: splitcontract_var_samp_order_by
  variance: splitcontract_variance_order_by
}

"order by avg() on columns of table \"hic_et_nunc.splitcontract\""
input splitcontract_avg_order_by {
  id: order_by
  total_shares: order_by
}

"Boolean expression to filter rows from the table \"hic_et_nunc.splitcontract\". All fields are combined with a logical 'AND'."
input splitcontract_bool_exp {
  _and: [splitcontract_bool_exp!]
  _not: splitcontract_bool_exp
  _or: [splitcontract_bool_exp!]
  administrator: String_comparison_exp
  contract: holder_bool_exp
  contract_id: String_comparison_exp
  id: Int_comparison_exp
  shareholder: shareholder_bool_exp
  total_shares: bigint_comparison_exp
}

"order by max() on columns of table \"hic_et_nunc.splitcontract\""
input splitcontract_max_order_by {
  administrator: order_by
  contract_id: order_by
  id: order_by
  total_shares: order_by
}

"order by min() on columns of table \"hic_et_nunc.splitcontract\""
input splitcontract_min_order_by {
  administrator: order_by
  contract_id: order_by
  id: order_by
  total_shares: order_by
}

"Ordering options when selecting data from \"hic_et_nunc.splitcontract\"."
input splitcontract_order_by {
  administrator: order_by
  contract: holder_order_by
  contract_id: order_by
  id: order_by
  shareholder_aggregate: shareholder_aggregate_order_by
  total_shares: order_by
}

"order by stddev() on columns of table \"hic_et_nunc.splitcontract\""
input splitcontract_stddev_order_by {
  id: order_by
  total_shares: order_by
}

"order by stddev_pop() on columns of table \"hic_et_nunc.splitcontract\""
input splitcontract_stddev_pop_order_by {
  id: order_by
  total_shares: order_by
}

"order by stddev_samp() on columns of table \"hic_et_nunc.splitcontract\""
input splitcontract_stddev_samp_order_by {
  id: order_by
  total_shares: order_by
}

"order by sum() on columns of table \"hic_et_nunc.splitcontract\""
input splitcontract_sum_order_by {
  id: order_by
  total_shares: order_by
}

"order by var_pop() on columns of table \"hic_et_nunc.splitcontract\""
input splitcontract_var_pop_order_by {
  id: order_by
  total_shares: order_by
}

"order by var_samp() on columns of table \"hic_et_nunc.splitcontract\""
input splitcontract_var_samp_order_by {
  id: order_by
  total_shares: order_by
}

"order by variance() on columns of table \"hic_et_nunc.splitcontract\""
input splitcontract_variance_order_by {
  id: order_by
  total_shares: order_by
}

"order by aggregate values of table \"hic_et_nunc.swap\""
input swap_aggregate_order_by {
  avg: swap_avg_order_by
  count: order_by
  max: swap_max_order_by
  min: swap_min_order_by
  stddev: swap_stddev_order_by
  stddev_pop: swap_stddev_pop_order_by
  stddev_samp: swap_stddev_samp_order_by
  sum: swap_sum_order_by
  var_pop: swap_var_pop_order_by
  var_samp: swap_var_samp_order_by
  variance: swap_variance_order_by
}

"order by avg() on columns of table \"hic_et_nunc.swap\""
input swap_avg_order_by {
  amount: order_by
  amount_left: order_by
  contract_version: order_by
  id: order_by
  level: order_by
  opid: order_by
  price: order_by
  royalties: order_by
  "ACTIVE: 0\\nFINISHED: 1\\nCANCELED: 2"
  status: order_by
  token_id: order_by
}

"Boolean expression to filter rows from the table \"hic_et_nunc.swap\". All fields are combined with a logical 'AND'."
input swap_bool_exp {
  _and: [swap_bool_exp!]
  _not: swap_bool_exp
  _or: [swap_bool_exp!]
  amount: smallint_comparison_exp
  amount_left: smallint_comparison_exp
  contract_address: String_comparison_exp
  contract_version: smallint_comparison_exp
  creator: holder_bool_exp
  creator_id: String_comparison_exp
  fa2: fa2_bool_exp
  fa2_id: String_comparison_exp
  id: bigint_comparison_exp
  is_valid: Boolean_comparison_exp
  level: bigint_comparison_exp
  ophash: String_comparison_exp
  opid: bigint_comparison_exp
  price: bigint_comparison_exp
  royalties: smallint_comparison_exp
  status: smallint_comparison_exp
  timestamp: timestamptz_comparison_exp
  token: token_bool_exp
  token_id: bigint_comparison_exp
  trades: trade_bool_exp
}

"order by max() on columns of table \"hic_et_nunc.swap\""
input swap_max_order_by {
  amount: order_by
  amount_left: order_by
  contract_address: order_by
  contract_version: order_by
  creator_id: order_by
  fa2_id: order_by
  id: order_by
  level: order_by
  ophash: order_by
  opid: order_by
  price: order_by
  royalties: order_by
  "ACTIVE: 0\\nFINISHED: 1\\nCANCELED: 2"
  status: order_by
  timestamp: order_by
  token_id: order_by
}

"order by min() on columns of table \"hic_et_nunc.swap\""
input swap_min_order_by {
  amount: order_by
  amount_left: order_by
  contract_address: order_by
  contract_version: order_by
  creator_id: order_by
  fa2_id: order_by
  id: order_by
  level: order_by
  ophash: order_by
  opid: order_by
  price: order_by
  royalties: order_by
  "ACTIVE: 0\\nFINISHED: 1\\nCANCELED: 2"
  status: order_by
  timestamp: order_by
  token_id: order_by
}

"Ordering options when selecting data from \"hic_et_nunc.swap\"."
input swap_order_by {
  amount: order_by
  amount_left: order_by
  contract_address: order_by
  contract_version: order_by
  creator: holder_order_by
  creator_id: order_by
  fa2: fa2_order_by
  fa2_id: order_by
  id: order_by
  is_valid: order_by
  level: order_by
  ophash: order_by
  opid: order_by
  price: order_by
  royalties: order_by
  status: order_by
  timestamp: order_by
  token: token_order_by
  token_id: order_by
  trades_aggregate: trade_aggregate_order_by
}

"order by stddev() on columns of table \"hic_et_nunc.swap\""
input swap_stddev_order_by {
  amount: order_by
  amount_left: order_by
  contract_version: order_by
  id: order_by
  level: order_by
  opid: order_by
  price: order_by
  royalties: order_by
  "ACTIVE: 0\\nFINISHED: 1\\nCANCELED: 2"
  status: order_by
  token_id: order_by
}

"order by stddev_pop() on columns of table \"hic_et_nunc.swap\""
input swap_stddev_pop_order_by {
  amount: order_by
  amount_left: order_by
  contract_version: order_by
  id: order_by
  level: order_by
  opid: order_by
  price: order_by
  royalties: order_by
  "ACTIVE: 0\\nFINISHED: 1\\nCANCELED: 2"
  status: order_by
  token_id: order_by
}

"order by stddev_samp() on columns of table \"hic_et_nunc.swap\""
input swap_stddev_samp_order_by {
  amount: order_by
  amount_left: order_by
  contract_version: order_by
  id: order_by
  level: order_by
  opid: order_by
  price: order_by
  royalties: order_by
  "ACTIVE: 0\\nFINISHED: 1\\nCANCELED: 2"
  status: order_by
  token_id: order_by
}

"order by sum() on columns of table \"hic_et_nunc.swap\""
input swap_sum_order_by {
  amount: order_by
  amount_left: order_by
  contract_version: order_by
  id: order_by
  level: order_by
  opid: order_by
  price: order_by
  royalties: order_by
  "ACTIVE: 0\\nFINISHED: 1\\nCANCELED: 2"
  status: order_by
  token_id: order_by
}

"order by var_pop() on columns of table \"hic_et_nunc.swap\""
input swap_var_pop_order_by {
  amount: order_by
  amount_left: order_by
  contract_version: order_by
  id: order_by
  level: order_by
  opid: order_by
  price: order_by
  royalties: order_by
  "ACTIVE: 0\\nFINISHED: 1\\nCANCELED: 2"
  status: order_by
  token_id: order_by
}

"order by var_samp() on columns of table \"hic_et_nunc.swap\""
input swap_var_samp_order_by {
  amount: order_by
  amount_left: order_by
  contract_version: order_by
  id: order_by
  level: order_by
  opid: order_by
  price: order_by
  royalties: order_by
  "ACTIVE: 0\\nFINISHED: 1\\nCANCELED: 2"
  status: order_by
  token_id: order_by
}

"order by variance() on columns of table \"hic_et_nunc.swap\""
input swap_variance_order_by {
  amount: order_by
  amount_left: order_by
  contract_version: order_by
  id: order_by
  level: order_by
  opid: order_by
  price: order_by
  royalties: order_by
  "ACTIVE: 0\\nFINISHED: 1\\nCANCELED: 2"
  status: order_by
  token_id: order_by
}

"Boolean expression to filter rows from the table \"hic_et_nunc.tag\". All fields are combined with a logical 'AND'."
input hic_et_nunc_tag_bool_exp {
  _and: [hic_et_nunc_tag_bool_exp!]
  _not: hic_et_nunc_tag_bool_exp
  _or: [hic_et_nunc_tag_bool_exp!]
  id: bigint_comparison_exp
  tag: String_comparison_exp
  tag_tokens: token_tag_bool_exp
}

"Ordering options when selecting data from \"hic_et_nunc.tag\"."
input hic_et_nunc_tag_order_by {
  id: order_by
  tag: order_by
  tag_tokens_aggregate: token_tag_aggregate_order_by
}

"order by aggregate values of table \"hic_et_nunc.token\""
input token_aggregate_order_by {
  avg: token_avg_order_by
  count: order_by
  max: token_max_order_by
  min: token_min_order_by
  stddev: token_stddev_order_by
  stddev_pop: token_stddev_pop_order_by
  stddev_samp: token_stddev_samp_order_by
  sum: token_sum_order_by
  var_pop: token_var_pop_order_by
  var_samp: token_var_samp_order_by
  variance: token_variance_order_by
}

"order by avg() on columns of table \"hic_et_nunc.token\""
input token_avg_order_by {
  hdao_balance: order_by
  id: order_by
  level: order_by
  royalties: order_by
  supply: order_by
}

"Boolean expression to filter rows from the table \"hic_et_nunc.token\". All fields are combined with a logical 'AND'."
input token_bool_exp {
  _and: [token_bool_exp!]
  _not: token_bool_exp
  _or: [token_bool_exp!]
  artifact_uri: String_comparison_exp
  creator: holder_bool_exp
  creator_id: String_comparison_exp
  description: String_comparison_exp
  display_uri: String_comparison_exp
  extra: jsonb_comparison_exp
  hdao_balance: bigint_comparison_exp
  id: bigint_comparison_exp
  is_signed: Boolean_comparison_exp
  level: bigint_comparison_exp
  metadata: String_comparison_exp
  mime: String_comparison_exp
  operators: token_operator_bool_exp
  royalties: smallint_comparison_exp
  supply: smallint_comparison_exp
  swaps: swap_bool_exp
  thumbnail_uri: String_comparison_exp
  timestamp: timestamptz_comparison_exp
  title: String_comparison_exp
  token_holders: token_holder_bool_exp
  token_signatures: hic_et_nunc_split_signatures_bool_exp
  token_tags: token_tag_bool_exp
  trades: trade_bool_exp
}

"order by aggregate values of table \"hic_et_nunc.token_holder\""
input token_holder_aggregate_order_by {
  avg: token_holder_avg_order_by
  count: order_by
  max: token_holder_max_order_by
  min: token_holder_min_order_by
  stddev: token_holder_stddev_order_by
  stddev_pop: token_holder_stddev_pop_order_by
  stddev_samp: token_holder_stddev_samp_order_by
  sum: token_holder_sum_order_by
  var_pop: token_holder_var_pop_order_by
  var_samp: token_holder_var_samp_order_by
  variance: token_holder_variance_order_by
}

"order by avg() on columns of table \"hic_et_nunc.token_holder\""
input token_holder_avg_order_by {
  id: order_by
  quantity: order_by
  token_id: order_by
}

"Boolean expression to filter rows from the table \"hic_et_nunc.token_holder\". All fields are combined with a logical 'AND'."
input token_holder_bool_exp {
  _and: [token_holder_bool_exp!]
  _not: token_holder_bool_exp
  _or: [token_holder_bool_exp!]
  holder: holder_bool_exp
  holder_id: String_comparison_exp
  id: Int_comparison_exp
  quantity: bigint_comparison_exp
  token: token_bool_exp
  token_id: bigint_comparison_exp
}

"order by max() on columns of table \"hic_et_nunc.token_holder\""
input token_holder_max_order_by {
  holder_id: order_by
  id: order_by
  quantity: order_by
  token_id: order_by
}

"order by min() on columns of table \"hic_et_nunc.token_holder\""
input token_holder_min_order_by {
  holder_id: order_by
  id: order_by
  quantity: order_by
  token_id: order_by
}

"Ordering options when selecting data from \"hic_et_nunc.token_holder\"."
input token_holder_order_by {
  holder: holder_order_by
  holder_id: order_by
  id: order_by
  quantity: order_by
  token: token_order_by
  token_id: order_by
}

"order by stddev() on columns of table \"hic_et_nunc.token_holder\""
input token_holder_stddev_order_by {
  id: order_by
  quantity: order_by
  token_id: order_by
}

"order by stddev_pop() on columns of table \"hic_et_nunc.token_holder\""
input token_holder_stddev_pop_order_by {
  id: order_by
  quantity: order_by
  token_id: order_by
}

"order by stddev_samp() on columns of table \"hic_et_nunc.token_holder\""
input token_holder_stddev_samp_order_by {
  id: order_by
  quantity: order_by
  token_id: order_by
}

"order by sum() on columns of table \"hic_et_nunc.token_holder\""
input token_holder_sum_order_by {
  id: order_by
  quantity: order_by
  token_id: order_by
}

"order by var_pop() on columns of table \"hic_et_nunc.token_holder\""
input token_holder_var_pop_order_by {
  id: order_by
  quantity: order_by
  token_id: order_by
}

"order by var_samp() on columns of table \"hic_et_nunc.token_holder\""
input token_holder_var_samp_order_by {
  id: order_by
  quantity: order_by
  token_id: order_by
}

"order by variance() on columns of table \"hic_et_nunc.token_holder\""
input token_holder_variance_order_by {
  id: order_by
  quantity: order_by
  token_id: order_by
}

"order by max() on columns of table \"hic_et_nunc.token\""
input token_max_order_by {
  artifact_uri: order_by
  creator_id: order_by
  description: order_by
  display_uri: order_by
  hdao_balance: order_by
  id: order_by
  level: order_by
  metadata: order_by
  mime: order_by
  royalties: order_by
  supply: order_by
  thumbnail_uri: order_by
  timestamp: order_by
  title: order_by
}

"order by min() on columns of table \"hic_et_nunc.token\""
input token_min_order_by {
  artifact_uri: order_by
  creator_id: order_by
  description: order_by
  display_uri: order_by
  hdao_balance: order_by
  id: order_by
  level: order_by
  metadata: order_by
  mime: order_by
  royalties: order_by
  supply: order_by
  thumbnail_uri: order_by
  timestamp: order_by
  title: order_by
}

"order by aggregate values of table \"hic_et_nunc.token_operator\""
input token_operator_aggregate_order_by {
  avg: token_operator_avg_order_by
  count: order_by
  max: token_operator_max_order_by
  min: token_operator_min_order_by
  stddev: token_operator_stddev_order_by
  stddev_pop: token_operator_stddev_pop_order_by
  stddev_samp: token_operator_stddev_samp_order_by
  sum: token_operator_sum_order_by
  var_pop: token_operator_var_pop_order_by
  var_samp: token_operator_var_samp_order_by
  variance: token_operator_variance_order_by
}

"order by avg() on columns of table \"hic_et_nunc.token_operator\""
input token_operator_avg_order_by {
  id: order_by
  level: order_by
  token_id: order_by
}

"Boolean expression to filter rows from the table \"hic_et_nunc.token_operator\". All fields are combined with a logical 'AND'."
input token_operator_bool_exp {
  _and: [token_operator_bool_exp!]
  _not: token_operator_bool_exp
  _or: [token_operator_bool_exp!]
  id: Int_comparison_exp
  level: bigint_comparison_exp
  operator: String_comparison_exp
  owner: holder_bool_exp
  owner_id: String_comparison_exp
  token: token_bool_exp
  token_id: bigint_comparison_exp
}

"order by max() on columns of table \"hic_et_nunc.token_operator\""
input token_operator_max_order_by {
  id: order_by
  level: order_by
  operator: order_by
  owner_id: order_by
  token_id: order_by
}

"order by min() on columns of table \"hic_et_nunc.token_operator\""
input token_operator_min_order_by {
  id: order_by
  level: order_by
  operator: order_by
  owner_id: order_by
  token_id: order_by
}

"Ordering options when selecting data from \"hic_et_nunc.token_operator\"."
input token_operator_order_by {
  id: order_by
  level: order_by
  operator: order_by
  owner: holder_order_by
  owner_id: order_by
  token: token_order_by
  token_id: order_by
}

"order by stddev() on columns of table \"hic_et_nunc.token_operator\""
input token_operator_stddev_order_by {
  id: order_by
  level: order_by
  token_id: order_by
}

"order by stddev_pop() on columns of table \"hic_et_nunc.token_operator\""
input token_operator_stddev_pop_order_by {
  id: order_by
  level: order_by
  token_id: order_by
}

"order by stddev_samp() on columns of table \"hic_et_nunc.token_operator\""
input token_operator_stddev_samp_order_by {
  id: order_by
  level: order_by
  token_id: order_by
}

"order by sum() on columns of table \"hic_et_nunc.token_operator\""
input token_operator_sum_order_by {
  id: order_by
  level: order_by
  token_id: order_by
}

"order by var_pop() on columns of table \"hic_et_nunc.token_operator\""
input token_operator_var_pop_order_by {
  id: order_by
  level: order_by
  token_id: order_by
}

"order by var_samp() on columns of table \"hic_et_nunc.token_operator\""
input token_operator_var_samp_order_by {
  id: order_by
  level: order_by
  token_id: order_by
}

"order by variance() on columns of table \"hic_et_nunc.token_operator\""
input token_operator_variance_order_by {
  id: order_by
  level: order_by
  token_id: order_by
}

"Ordering options when selecting data from \"hic_et_nunc.token\"."
input token_order_by {
  artifact_uri: order_by
  creator: holder_order_by
  creator_id: order_by
  description: order_by
  display_uri: order_by
  extra: order_by
  hdao_balance: order_by
  id: order_by
  is_signed: order_by
  level: order_by
  metadata: order_by
  mime: order_by
  operators_aggregate: token_operator_aggregate_order_by
  royalties: order_by
  supply: order_by
  swaps_aggregate: swap_aggregate_order_by
  thumbnail_uri: order_by
  timestamp: order_by
  title: order_by
  token_holders_aggregate: token_holder_aggregate_order_by
  token_signatures_aggregate: hic_et_nunc_split_signatures_aggregate_order_by
  token_tags_aggregate: token_tag_aggregate_order_by
  trades_aggregate: trade_aggregate_order_by
}

"order by stddev() on columns of table \"hic_et_nunc.token\""
input token_stddev_order_by {
  hdao_balance: order_by
  id: order_by
  level: order_by
  royalties: order_by
  supply: order_by
}

"order by stddev_pop() on columns of table \"hic_et_nunc.token\""
input token_stddev_pop_order_by {
  hdao_balance: order_by
  id: order_by
  level: order_by
  royalties: order_by
  supply: order_by
}

"order by stddev_samp() on columns of table \"hic_et_nunc.token\""
input token_stddev_samp_order_by {
  hdao_balance: order_by
  id: order_by
  level: order_by
  royalties: order_by
  supply: order_by
}

"order by sum() on columns of table \"hic_et_nunc.token\""
input token_sum_order_by {
  hdao_balance: order_by
  id: order_by
  level: order_by
  royalties: order_by
  supply: order_by
}

"order by aggregate values of table \"hic_et_nunc.token_tag\""
input token_tag_aggregate_order_by {
  avg: token_tag_avg_order_by
  count: order_by
  max: token_tag_max_order_by
  min: token_tag_min_order_by
  stddev: token_tag_stddev_order_by
  stddev_pop: token_tag_stddev_pop_order_by
  stddev_samp: token_tag_stddev_samp_order_by
  sum: token_tag_sum_order_by
  var_pop: token_tag_var_pop_order_by
  var_samp: token_tag_var_samp_order_by
  variance: token_tag_variance_order_by
}

"order by avg() on columns of table \"hic_et_nunc.token_tag\""
input token_tag_avg_order_by {
  id: order_by
  tag_id: order_by
  token_id: order_by
}

"Boolean expression to filter rows from the table \"hic_et_nunc.token_tag\". All fields are combined with a logical 'AND'."
input token_tag_bool_exp {
  _and: [token_tag_bool_exp!]
  _not: token_tag_bool_exp
  _or: [token_tag_bool_exp!]
  id: Int_comparison_exp
  tag: hic_et_nunc_tag_bool_exp
  tag_id: bigint_comparison_exp
  token: token_bool_exp
  token_id: bigint_comparison_exp
}

"order by max() on columns of table \"hic_et_nunc.token_tag\""
input token_tag_max_order_by {
  id: order_by
  tag_id: order_by
  token_id: order_by
}

"order by min() on columns of table \"hic_et_nunc.token_tag\""
input token_tag_min_order_by {
  id: order_by
  tag_id: order_by
  token_id: order_by
}

"Ordering options when selecting data from \"hic_et_nunc.token_tag\"."
input token_tag_order_by {
  id: order_by
  tag: hic_et_nunc_tag_order_by
  tag_id: order_by
  token: token_order_by
  token_id: order_by
}

"order by stddev() on columns of table \"hic_et_nunc.token_tag\""
input token_tag_stddev_order_by {
  id: order_by
  tag_id: order_by
  token_id: order_by
}

"order by stddev_pop() on columns of table \"hic_et_nunc.token_tag\""
input token_tag_stddev_pop_order_by {
  id: order_by
  tag_id: order_by
  token_id: order_by
}

"order by stddev_samp() on columns of table \"hic_et_nunc.token_tag\""
input token_tag_stddev_samp_order_by {
  id: order_by
  tag_id: order_by
  token_id: order_by
}

"order by sum() on columns of table \"hic_et_nunc.token_tag\""
input token_tag_sum_order_by {
  id: order_by
  tag_id: order_by
  token_id: order_by
}

"order by var_pop() on columns of table \"hic_et_nunc.token_tag\""
input token_tag_var_pop_order_by {
  id: order_by
  tag_id: order_by
  token_id: order_by
}

"order by var_samp() on columns of table \"hic_et_nunc.token_tag\""
input token_tag_var_samp_order_by {
  id: order_by
  tag_id: order_by
  token_id: order_by
}

"order by variance() on columns of table \"hic_et_nunc.token_tag\""
input token_tag_variance_order_by {
  id: order_by
  tag_id: order_by
  token_id: order_by
}

"order by var_pop() on columns of table \"hic_et_nunc.token\""
input token_var_pop_order_by {
  hdao_balance: order_by
  id: order_by
  level: order_by
  royalties: order_by
  supply: order_by
}

"order by var_samp() on columns of table \"hic_et_nunc.token\""
input token_var_samp_order_by {
  hdao_balance: order_by
  id: order_by
  level: order_by
  royalties: order_by
  supply: order_by
}

"order by variance() on columns of table \"hic_et_nunc.token\""
input token_variance_order_by {
  hdao_balance: order_by
  id: order_by
  level: order_by
  royalties: order_by
  supply: order_by
}

"order by aggregate values of table \"hic_et_nunc.trade\""
input trade_aggregate_order_by {
  avg: trade_avg_order_by
  count: order_by
  max: trade_max_order_by
  min: trade_min_order_by
  stddev: trade_stddev_order_by
  stddev_pop: trade_stddev_pop_order_by
  stddev_samp: trade_stddev_samp_order_by
  sum: trade_sum_order_by
  var_pop: trade_var_pop_order_by
  var_samp: trade_var_samp_order_by
  variance: trade_variance_order_by
}

"order by avg() on columns of table \"hic_et_nunc.trade\""
input trade_avg_order_by {
  amount: order_by
  id: order_by
  level: order_by
  swap_id: order_by
  token_id: order_by
}

"Boolean expression to filter rows from the table \"hic_et_nunc.trade\". All fields are combined with a logical 'AND'."
input trade_bool_exp {
  _and: [trade_bool_exp!]
  _not: trade_bool_exp
  _or: [trade_bool_exp!]
  amount: bigint_comparison_exp
  buyer: holder_bool_exp
  buyer_id: String_comparison_exp
  id: bigint_comparison_exp
  level: bigint_comparison_exp
  ophash: String_comparison_exp
  seller: holder_bool_exp
  seller_id: String_comparison_exp
  swap: swap_bool_exp
  swap_id: bigint_comparison_exp
  timestamp: timestamptz_comparison_exp
  token: token_bool_exp
  token_id: bigint_comparison_exp
}

"order by max() on columns of table \"hic_et_nunc.trade\""
input trade_max_order_by {
  amount: order_by
  buyer_id: order_by
  id: order_by
  level: order_by
  ophash: order_by
  seller_id: order_by
  swap_id: order_by
  timestamp: order_by
  token_id: order_by
}

"order by min() on columns of table \"hic_et_nunc.trade\""
input trade_min_order_by {
  amount: order_by
  buyer_id: order_by
  id: order_by
  level: order_by
  ophash: order_by
  seller_id: order_by
  swap_id: order_by
  timestamp: order_by
  token_id: order_by
}

"Ordering options when selecting data from \"hic_et_nunc.trade\"."
input trade_order_by {
  amount: order_by
  buyer: holder_order_by
  buyer_id: order_by
  id: order_by
  level: order_by
  ophash: order_by
  seller: holder_order_by
  seller_id: order_by
  swap: swap_order_by
  swap_id: order_by
  timestamp: order_by
  token: token_order_by
  token_id: order_by
}

"order by stddev() on columns of table \"hic_et_nunc.trade\""
input trade_stddev_order_by {
  amount: order_by
  id: order_by
  level: order_by
  swap_id: order_by
  token_id: order_by
}

"order by stddev_pop() on columns of table \"hic_et_nunc.trade\""
input trade_stddev_pop_order_by {
  amount: order_by
  id: order_by
  level: order_by
  swap_id: order_by
  token_id: order_by
}

"order by stddev_samp() on columns of table \"hic_et_nunc.trade\""
input trade_stddev_samp_order_by {
  amount: order_by
  id: order_by
  level: order_by
  swap_id: order_by
  token_id: order_by
}

"order by sum() on columns of table \"hic_et_nunc.trade\""
input trade_sum_order_by {
  amount: order_by
  id: order_by
  level: order_by
  swap_id: order_by
  token_id: order_by
}

"order by var_pop() on columns of table \"hic_et_nunc.trade\""
input trade_var_pop_order_by {
  amount: order_by
  id: order_by
  level: order_by
  swap_id: order_by
  token_id: order_by
}

"order by var_samp() on columns of table \"hic_et_nunc.trade\""
input trade_var_samp_order_by {
  amount: order_by
  id: order_by
  level: order_by
  swap_id: order_by
  token_id: order_by
}

"order by variance() on columns of table \"hic_et_nunc.trade\""
input trade_variance_order_by {
  amount: order_by
  id: order_by
  level: order_by
  swap_id: order_by
  token_id: order_by
}

"Boolean expression to compare columns of type \"jsonb\". All fields are combined with logical 'AND'."
input jsonb_comparison_exp {
  "is the column contained in the given json value"
  _contained_in: jsonb
  "does the column contain the given json value at the top level"
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb
  "does the string exist as a top-level key in the column"
  _has_key: String
  "do all of these strings exist as top-level keys in the column"
  _has_keys_all: [String!]
  "do any of these strings exist as top-level keys in the column"
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"Boolean expression to compare columns of type \"smallint\". All fields are combined with logical 'AND'."
input smallint_comparison_exp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _is_null: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

"Boolean expression to compare columns of type \"timestamptz\". All fields are combined with logical 'AND'."
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}
