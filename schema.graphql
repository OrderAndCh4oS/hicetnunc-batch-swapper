schema {
  query: query_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
columns and relationships of "dipdup_contract"
"""
type dipdup_contract {
  address: String!
  created_at: timestamptz!
  name: String!
  typename: String
  updated_at: timestamptz!
}

"""
aggregated selection of "dipdup_contract"
"""
type dipdup_contract_aggregate {
  aggregate: dipdup_contract_aggregate_fields
  nodes: [dipdup_contract!]!
}

"""
aggregate fields of "dipdup_contract"
"""
type dipdup_contract_aggregate_fields {
  count(columns: [dipdup_contract_select_column!], distinct: Boolean): Int!
  max: dipdup_contract_max_fields
  min: dipdup_contract_min_fields
}

"""
Boolean expression to filter rows from the table "dipdup_contract". All fields are combined with a logical 'AND'.
"""
input dipdup_contract_bool_exp {
  _and: [dipdup_contract_bool_exp!]
  _not: dipdup_contract_bool_exp
  _or: [dipdup_contract_bool_exp!]
  address: String_comparison_exp
  created_at: timestamptz_comparison_exp
  name: String_comparison_exp
  typename: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""aggregate max on columns"""
type dipdup_contract_max_fields {
  address: String
  created_at: timestamptz
  name: String
  typename: String
  updated_at: timestamptz
}

"""
columns and relationships of "dipdup_contract_metadata"
"""
type dipdup_contract_metadata {
  contract: String!
  created_at: timestamptz!
  id: Int!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb!
  network: String!
  update_id: Int!
  updated_at: timestamptz!
}

"""
aggregated selection of "dipdup_contract_metadata"
"""
type dipdup_contract_metadata_aggregate {
  aggregate: dipdup_contract_metadata_aggregate_fields
  nodes: [dipdup_contract_metadata!]!
}

"""
aggregate fields of "dipdup_contract_metadata"
"""
type dipdup_contract_metadata_aggregate_fields {
  avg: dipdup_contract_metadata_avg_fields
  count(columns: [dipdup_contract_metadata_select_column!], distinct: Boolean): Int!
  max: dipdup_contract_metadata_max_fields
  min: dipdup_contract_metadata_min_fields
  stddev: dipdup_contract_metadata_stddev_fields
  stddev_pop: dipdup_contract_metadata_stddev_pop_fields
  stddev_samp: dipdup_contract_metadata_stddev_samp_fields
  sum: dipdup_contract_metadata_sum_fields
  var_pop: dipdup_contract_metadata_var_pop_fields
  var_samp: dipdup_contract_metadata_var_samp_fields
  variance: dipdup_contract_metadata_variance_fields
}

"""aggregate avg on columns"""
type dipdup_contract_metadata_avg_fields {
  id: Float
  update_id: Float
}

"""
Boolean expression to filter rows from the table "dipdup_contract_metadata". All fields are combined with a logical 'AND'.
"""
input dipdup_contract_metadata_bool_exp {
  _and: [dipdup_contract_metadata_bool_exp!]
  _not: dipdup_contract_metadata_bool_exp
  _or: [dipdup_contract_metadata_bool_exp!]
  contract: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: Int_comparison_exp
  metadata: jsonb_comparison_exp
  network: String_comparison_exp
  update_id: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""aggregate max on columns"""
type dipdup_contract_metadata_max_fields {
  contract: String
  created_at: timestamptz
  id: Int
  network: String
  update_id: Int
  updated_at: timestamptz
}

"""aggregate min on columns"""
type dipdup_contract_metadata_min_fields {
  contract: String
  created_at: timestamptz
  id: Int
  network: String
  update_id: Int
  updated_at: timestamptz
}

"""Ordering options when selecting data from "dipdup_contract_metadata"."""
input dipdup_contract_metadata_order_by {
  contract: order_by
  created_at: order_by
  id: order_by
  metadata: order_by
  network: order_by
  update_id: order_by
  updated_at: order_by
}

"""
select columns of table "dipdup_contract_metadata"
"""
enum dipdup_contract_metadata_select_column {
  """column name"""
  contract

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  network

  """column name"""
  update_id

  """column name"""
  updated_at
}

"""aggregate stddev on columns"""
type dipdup_contract_metadata_stddev_fields {
  id: Float
  update_id: Float
}

"""aggregate stddev_pop on columns"""
type dipdup_contract_metadata_stddev_pop_fields {
  id: Float
  update_id: Float
}

"""aggregate stddev_samp on columns"""
type dipdup_contract_metadata_stddev_samp_fields {
  id: Float
  update_id: Float
}

"""aggregate sum on columns"""
type dipdup_contract_metadata_sum_fields {
  id: Int
  update_id: Int
}

"""aggregate var_pop on columns"""
type dipdup_contract_metadata_var_pop_fields {
  id: Float
  update_id: Float
}

"""aggregate var_samp on columns"""
type dipdup_contract_metadata_var_samp_fields {
  id: Float
  update_id: Float
}

"""aggregate variance on columns"""
type dipdup_contract_metadata_variance_fields {
  id: Float
  update_id: Float
}

"""aggregate min on columns"""
type dipdup_contract_min_fields {
  address: String
  created_at: timestamptz
  name: String
  typename: String
  updated_at: timestamptz
}

"""Ordering options when selecting data from "dipdup_contract"."""
input dipdup_contract_order_by {
  address: order_by
  created_at: order_by
  name: order_by
  typename: order_by
  updated_at: order_by
}

"""
select columns of table "dipdup_contract"
"""
enum dipdup_contract_select_column {
  """column name"""
  address

  """column name"""
  created_at

  """column name"""
  name

  """column name"""
  typename

  """column name"""
  updated_at
}

"""
columns and relationships of "dipdup_head"
"""
type dipdup_head {
  created_at: timestamptz!
  hash: String!
  level: Int!
  name: String!
  timestamp: timestamptz!
  updated_at: timestamptz!
}

"""
aggregated selection of "dipdup_head"
"""
type dipdup_head_aggregate {
  aggregate: dipdup_head_aggregate_fields
  nodes: [dipdup_head!]!
}

"""
aggregate fields of "dipdup_head"
"""
type dipdup_head_aggregate_fields {
  avg: dipdup_head_avg_fields
  count(columns: [dipdup_head_select_column!], distinct: Boolean): Int!
  max: dipdup_head_max_fields
  min: dipdup_head_min_fields
  stddev: dipdup_head_stddev_fields
  stddev_pop: dipdup_head_stddev_pop_fields
  stddev_samp: dipdup_head_stddev_samp_fields
  sum: dipdup_head_sum_fields
  var_pop: dipdup_head_var_pop_fields
  var_samp: dipdup_head_var_samp_fields
  variance: dipdup_head_variance_fields
}

"""aggregate avg on columns"""
type dipdup_head_avg_fields {
  level: Float
}

"""
Boolean expression to filter rows from the table "dipdup_head". All fields are combined with a logical 'AND'.
"""
input dipdup_head_bool_exp {
  _and: [dipdup_head_bool_exp!]
  _not: dipdup_head_bool_exp
  _or: [dipdup_head_bool_exp!]
  created_at: timestamptz_comparison_exp
  hash: String_comparison_exp
  level: Int_comparison_exp
  name: String_comparison_exp
  timestamp: timestamptz_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""aggregate max on columns"""
type dipdup_head_max_fields {
  created_at: timestamptz
  hash: String
  level: Int
  name: String
  timestamp: timestamptz
  updated_at: timestamptz
}

"""aggregate min on columns"""
type dipdup_head_min_fields {
  created_at: timestamptz
  hash: String
  level: Int
  name: String
  timestamp: timestamptz
  updated_at: timestamptz
}

"""Ordering options when selecting data from "dipdup_head"."""
input dipdup_head_order_by {
  created_at: order_by
  hash: order_by
  level: order_by
  name: order_by
  timestamp: order_by
  updated_at: order_by
}

"""
select columns of table "dipdup_head"
"""
enum dipdup_head_select_column {
  """column name"""
  created_at

  """column name"""
  hash

  """column name"""
  level

  """column name"""
  name

  """column name"""
  timestamp

  """column name"""
  updated_at
}

"""
columns and relationships of "dipdup_head_status"
"""
type dipdup_head_status {
  name: String
  status: String
}

"""
aggregated selection of "dipdup_head_status"
"""
type dipdup_head_status_aggregate {
  aggregate: dipdup_head_status_aggregate_fields
  nodes: [dipdup_head_status!]!
}

"""
aggregate fields of "dipdup_head_status"
"""
type dipdup_head_status_aggregate_fields {
  count(columns: [dipdup_head_status_select_column!], distinct: Boolean): Int!
  max: dipdup_head_status_max_fields
  min: dipdup_head_status_min_fields
}

"""
Boolean expression to filter rows from the table "dipdup_head_status". All fields are combined with a logical 'AND'.
"""
input dipdup_head_status_bool_exp {
  _and: [dipdup_head_status_bool_exp!]
  _not: dipdup_head_status_bool_exp
  _or: [dipdup_head_status_bool_exp!]
  name: String_comparison_exp
  status: String_comparison_exp
}

"""aggregate max on columns"""
type dipdup_head_status_max_fields {
  name: String
  status: String
}

"""aggregate min on columns"""
type dipdup_head_status_min_fields {
  name: String
  status: String
}

"""Ordering options when selecting data from "dipdup_head_status"."""
input dipdup_head_status_order_by {
  name: order_by
  status: order_by
}

"""
select columns of table "dipdup_head_status"
"""
enum dipdup_head_status_select_column {
  """column name"""
  name

  """column name"""
  status
}

"""aggregate stddev on columns"""
type dipdup_head_stddev_fields {
  level: Float
}

"""aggregate stddev_pop on columns"""
type dipdup_head_stddev_pop_fields {
  level: Float
}

"""aggregate stddev_samp on columns"""
type dipdup_head_stddev_samp_fields {
  level: Float
}

"""aggregate sum on columns"""
type dipdup_head_sum_fields {
  level: Int
}

"""aggregate var_pop on columns"""
type dipdup_head_var_pop_fields {
  level: Float
}

"""aggregate var_samp on columns"""
type dipdup_head_var_samp_fields {
  level: Float
}

"""aggregate variance on columns"""
type dipdup_head_variance_fields {
  level: Float
}

"""
columns and relationships of "dipdup_index"
"""
type dipdup_index {
  config_hash: String!
  created_at: timestamptz!
  level: Int!
  name: String!

  """
  NEW: NEW\nSYNCING: SYNCING\nREALTIME: REALTIME\nROLLBACK: ROLLBACK\nONESHOT: ONESHOT
  """
  status: String!
  template: String
  template_values(
    """JSON select path"""
    path: String
  ): jsonb

  """
  operation: operation\nbig_map: big_map\nhead: head\ntoken_transfer: token_transfer
  """
  type: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "dipdup_index"
"""
type dipdup_index_aggregate {
  aggregate: dipdup_index_aggregate_fields
  nodes: [dipdup_index!]!
}

"""
aggregate fields of "dipdup_index"
"""
type dipdup_index_aggregate_fields {
  avg: dipdup_index_avg_fields
  count(columns: [dipdup_index_select_column!], distinct: Boolean): Int!
  max: dipdup_index_max_fields
  min: dipdup_index_min_fields
  stddev: dipdup_index_stddev_fields
  stddev_pop: dipdup_index_stddev_pop_fields
  stddev_samp: dipdup_index_stddev_samp_fields
  sum: dipdup_index_sum_fields
  var_pop: dipdup_index_var_pop_fields
  var_samp: dipdup_index_var_samp_fields
  variance: dipdup_index_variance_fields
}

"""aggregate avg on columns"""
type dipdup_index_avg_fields {
  level: Float
}

"""
Boolean expression to filter rows from the table "dipdup_index". All fields are combined with a logical 'AND'.
"""
input dipdup_index_bool_exp {
  _and: [dipdup_index_bool_exp!]
  _not: dipdup_index_bool_exp
  _or: [dipdup_index_bool_exp!]
  config_hash: String_comparison_exp
  created_at: timestamptz_comparison_exp
  level: Int_comparison_exp
  name: String_comparison_exp
  status: String_comparison_exp
  template: String_comparison_exp
  template_values: jsonb_comparison_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""aggregate max on columns"""
type dipdup_index_max_fields {
  config_hash: String
  created_at: timestamptz
  level: Int
  name: String

  """
  NEW: NEW\nSYNCING: SYNCING\nREALTIME: REALTIME\nROLLBACK: ROLLBACK\nONESHOT: ONESHOT
  """
  status: String
  template: String

  """
  operation: operation\nbig_map: big_map\nhead: head\ntoken_transfer: token_transfer
  """
  type: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type dipdup_index_min_fields {
  config_hash: String
  created_at: timestamptz
  level: Int
  name: String

  """
  NEW: NEW\nSYNCING: SYNCING\nREALTIME: REALTIME\nROLLBACK: ROLLBACK\nONESHOT: ONESHOT
  """
  status: String
  template: String

  """
  operation: operation\nbig_map: big_map\nhead: head\ntoken_transfer: token_transfer
  """
  type: String
  updated_at: timestamptz
}

"""Ordering options when selecting data from "dipdup_index"."""
input dipdup_index_order_by {
  config_hash: order_by
  created_at: order_by
  level: order_by
  name: order_by
  status: order_by
  template: order_by
  template_values: order_by
  type: order_by
  updated_at: order_by
}

"""
select columns of table "dipdup_index"
"""
enum dipdup_index_select_column {
  """column name"""
  config_hash

  """column name"""
  created_at

  """column name"""
  level

  """column name"""
  name

  """column name"""
  status

  """column name"""
  template

  """column name"""
  template_values

  """column name"""
  type

  """column name"""
  updated_at
}

"""aggregate stddev on columns"""
type dipdup_index_stddev_fields {
  level: Float
}

"""aggregate stddev_pop on columns"""
type dipdup_index_stddev_pop_fields {
  level: Float
}

"""aggregate stddev_samp on columns"""
type dipdup_index_stddev_samp_fields {
  level: Float
}

"""aggregate sum on columns"""
type dipdup_index_sum_fields {
  level: Int
}

"""aggregate var_pop on columns"""
type dipdup_index_var_pop_fields {
  level: Float
}

"""aggregate var_samp on columns"""
type dipdup_index_var_samp_fields {
  level: Float
}

"""aggregate variance on columns"""
type dipdup_index_variance_fields {
  level: Float
}

"""Model update created within versioned transactions"""
type dipdup_model_update {
  """INSERT: INSERT\nUPDATE: UPDATE\nDELETE: DELETE"""
  action: String!
  created_at: timestamptz!
  data(
    """JSON select path"""
    path: String
  ): jsonb
  id: Int!
  index: String!
  level: Int!
  model_name: String!
  model_pk: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "dipdup_model_update"
"""
type dipdup_model_update_aggregate {
  aggregate: dipdup_model_update_aggregate_fields
  nodes: [dipdup_model_update!]!
}

"""
aggregate fields of "dipdup_model_update"
"""
type dipdup_model_update_aggregate_fields {
  avg: dipdup_model_update_avg_fields
  count(columns: [dipdup_model_update_select_column!], distinct: Boolean): Int!
  max: dipdup_model_update_max_fields
  min: dipdup_model_update_min_fields
  stddev: dipdup_model_update_stddev_fields
  stddev_pop: dipdup_model_update_stddev_pop_fields
  stddev_samp: dipdup_model_update_stddev_samp_fields
  sum: dipdup_model_update_sum_fields
  var_pop: dipdup_model_update_var_pop_fields
  var_samp: dipdup_model_update_var_samp_fields
  variance: dipdup_model_update_variance_fields
}

"""aggregate avg on columns"""
type dipdup_model_update_avg_fields {
  id: Float
  level: Float
}

"""
Boolean expression to filter rows from the table "dipdup_model_update". All fields are combined with a logical 'AND'.
"""
input dipdup_model_update_bool_exp {
  _and: [dipdup_model_update_bool_exp!]
  _not: dipdup_model_update_bool_exp
  _or: [dipdup_model_update_bool_exp!]
  action: String_comparison_exp
  created_at: timestamptz_comparison_exp
  data: jsonb_comparison_exp
  id: Int_comparison_exp
  index: String_comparison_exp
  level: Int_comparison_exp
  model_name: String_comparison_exp
  model_pk: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""aggregate max on columns"""
type dipdup_model_update_max_fields {
  """INSERT: INSERT\nUPDATE: UPDATE\nDELETE: DELETE"""
  action: String
  created_at: timestamptz
  id: Int
  index: String
  level: Int
  model_name: String
  model_pk: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type dipdup_model_update_min_fields {
  """INSERT: INSERT\nUPDATE: UPDATE\nDELETE: DELETE"""
  action: String
  created_at: timestamptz
  id: Int
  index: String
  level: Int
  model_name: String
  model_pk: String
  updated_at: timestamptz
}

"""Ordering options when selecting data from "dipdup_model_update"."""
input dipdup_model_update_order_by {
  action: order_by
  created_at: order_by
  data: order_by
  id: order_by
  index: order_by
  level: order_by
  model_name: order_by
  model_pk: order_by
  updated_at: order_by
}

"""
select columns of table "dipdup_model_update"
"""
enum dipdup_model_update_select_column {
  """column name"""
  action

  """column name"""
  created_at

  """column name"""
  data

  """column name"""
  id

  """column name"""
  index

  """column name"""
  level

  """column name"""
  model_name

  """column name"""
  model_pk

  """column name"""
  updated_at
}

"""aggregate stddev on columns"""
type dipdup_model_update_stddev_fields {
  id: Float
  level: Float
}

"""aggregate stddev_pop on columns"""
type dipdup_model_update_stddev_pop_fields {
  id: Float
  level: Float
}

"""aggregate stddev_samp on columns"""
type dipdup_model_update_stddev_samp_fields {
  id: Float
  level: Float
}

"""aggregate sum on columns"""
type dipdup_model_update_sum_fields {
  id: Int
  level: Int
}

"""aggregate var_pop on columns"""
type dipdup_model_update_var_pop_fields {
  id: Float
  level: Float
}

"""aggregate var_samp on columns"""
type dipdup_model_update_var_samp_fields {
  id: Float
  level: Float
}

"""aggregate variance on columns"""
type dipdup_model_update_variance_fields {
  id: Float
  level: Float
}

"""
columns and relationships of "dipdup_schema"
"""
type dipdup_schema {
  created_at: timestamptz!
  hash: String!
  name: String!

  """
  manual: manual\nmigration: migration\nrollback: rollback\nconfig_modified:
  config_modified\nschema_modified: schema_modified
  """
  reindex: String
  updated_at: timestamptz!
}

"""
aggregated selection of "dipdup_schema"
"""
type dipdup_schema_aggregate {
  aggregate: dipdup_schema_aggregate_fields
  nodes: [dipdup_schema!]!
}

"""
aggregate fields of "dipdup_schema"
"""
type dipdup_schema_aggregate_fields {
  count(columns: [dipdup_schema_select_column!], distinct: Boolean): Int!
  max: dipdup_schema_max_fields
  min: dipdup_schema_min_fields
}

"""
Boolean expression to filter rows from the table "dipdup_schema". All fields are combined with a logical 'AND'.
"""
input dipdup_schema_bool_exp {
  _and: [dipdup_schema_bool_exp!]
  _not: dipdup_schema_bool_exp
  _or: [dipdup_schema_bool_exp!]
  created_at: timestamptz_comparison_exp
  hash: String_comparison_exp
  name: String_comparison_exp
  reindex: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""aggregate max on columns"""
type dipdup_schema_max_fields {
  created_at: timestamptz
  hash: String
  name: String

  """
  manual: manual\nmigration: migration\nrollback: rollback\nconfig_modified:
  config_modified\nschema_modified: schema_modified
  """
  reindex: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type dipdup_schema_min_fields {
  created_at: timestamptz
  hash: String
  name: String

  """
  manual: manual\nmigration: migration\nrollback: rollback\nconfig_modified:
  config_modified\nschema_modified: schema_modified
  """
  reindex: String
  updated_at: timestamptz
}

"""Ordering options when selecting data from "dipdup_schema"."""
input dipdup_schema_order_by {
  created_at: order_by
  hash: order_by
  name: order_by
  reindex: order_by
  updated_at: order_by
}

"""
select columns of table "dipdup_schema"
"""
enum dipdup_schema_select_column {
  """column name"""
  created_at

  """column name"""
  hash

  """column name"""
  name

  """column name"""
  reindex

  """column name"""
  updated_at
}

"""
columns and relationships of "dipdup_token_metadata"
"""
type dipdup_token_metadata {
  contract: String!
  created_at: timestamptz!
  id: Int!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb!
  network: String!
  token_id: String!
  update_id: Int!
  updated_at: timestamptz!
}

"""
aggregated selection of "dipdup_token_metadata"
"""
type dipdup_token_metadata_aggregate {
  aggregate: dipdup_token_metadata_aggregate_fields
  nodes: [dipdup_token_metadata!]!
}

"""
aggregate fields of "dipdup_token_metadata"
"""
type dipdup_token_metadata_aggregate_fields {
  avg: dipdup_token_metadata_avg_fields
  count(columns: [dipdup_token_metadata_select_column!], distinct: Boolean): Int!
  max: dipdup_token_metadata_max_fields
  min: dipdup_token_metadata_min_fields
  stddev: dipdup_token_metadata_stddev_fields
  stddev_pop: dipdup_token_metadata_stddev_pop_fields
  stddev_samp: dipdup_token_metadata_stddev_samp_fields
  sum: dipdup_token_metadata_sum_fields
  var_pop: dipdup_token_metadata_var_pop_fields
  var_samp: dipdup_token_metadata_var_samp_fields
  variance: dipdup_token_metadata_variance_fields
}

"""aggregate avg on columns"""
type dipdup_token_metadata_avg_fields {
  id: Float
  update_id: Float
}

"""
Boolean expression to filter rows from the table "dipdup_token_metadata". All fields are combined with a logical 'AND'.
"""
input dipdup_token_metadata_bool_exp {
  _and: [dipdup_token_metadata_bool_exp!]
  _not: dipdup_token_metadata_bool_exp
  _or: [dipdup_token_metadata_bool_exp!]
  contract: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: Int_comparison_exp
  metadata: jsonb_comparison_exp
  network: String_comparison_exp
  token_id: String_comparison_exp
  update_id: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""aggregate max on columns"""
type dipdup_token_metadata_max_fields {
  contract: String
  created_at: timestamptz
  id: Int
  network: String
  token_id: String
  update_id: Int
  updated_at: timestamptz
}

"""aggregate min on columns"""
type dipdup_token_metadata_min_fields {
  contract: String
  created_at: timestamptz
  id: Int
  network: String
  token_id: String
  update_id: Int
  updated_at: timestamptz
}

"""Ordering options when selecting data from "dipdup_token_metadata"."""
input dipdup_token_metadata_order_by {
  contract: order_by
  created_at: order_by
  id: order_by
  metadata: order_by
  network: order_by
  token_id: order_by
  update_id: order_by
  updated_at: order_by
}

"""
select columns of table "dipdup_token_metadata"
"""
enum dipdup_token_metadata_select_column {
  """column name"""
  contract

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  network

  """column name"""
  token_id

  """column name"""
  update_id

  """column name"""
  updated_at
}

"""aggregate stddev on columns"""
type dipdup_token_metadata_stddev_fields {
  id: Float
  update_id: Float
}

"""aggregate stddev_pop on columns"""
type dipdup_token_metadata_stddev_pop_fields {
  id: Float
  update_id: Float
}

"""aggregate stddev_samp on columns"""
type dipdup_token_metadata_stddev_samp_fields {
  id: Float
  update_id: Float
}

"""aggregate sum on columns"""
type dipdup_token_metadata_sum_fields {
  id: Int
  update_id: Int
}

"""aggregate var_pop on columns"""
type dipdup_token_metadata_var_pop_fields {
  id: Float
  update_id: Float
}

"""aggregate var_samp on columns"""
type dipdup_token_metadata_var_samp_fields {
  id: Float
  update_id: Float
}

"""aggregate variance on columns"""
type dipdup_token_metadata_variance_fields {
  id: Float
  update_id: Float
}

"""
columns and relationships of "fa2"
"""
type fa2 {
  contract: String!

  """An array relationship"""
  swaps(
    """distinct select on columns"""
    distinct_on: [swap_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [swap_order_by!]

    """filter the rows returned"""
    where: swap_bool_exp
  ): [swap!]!

  """An aggregate relationship"""
  swaps_aggregate(
    """distinct select on columns"""
    distinct_on: [swap_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [swap_order_by!]

    """filter the rows returned"""
    where: swap_bool_exp
  ): swap_aggregate!
}

"""
aggregated selection of "fa2"
"""
type fa2_aggregate {
  aggregate: fa2_aggregate_fields
  nodes: [fa2!]!
}

"""
aggregate fields of "fa2"
"""
type fa2_aggregate_fields {
  count(columns: [fa2_select_column!], distinct: Boolean): Int!
  max: fa2_max_fields
  min: fa2_min_fields
}

"""
Boolean expression to filter rows from the table "fa2". All fields are combined with a logical 'AND'.
"""
input fa2_bool_exp {
  _and: [fa2_bool_exp!]
  _not: fa2_bool_exp
  _or: [fa2_bool_exp!]
  contract: String_comparison_exp
  swaps: swap_bool_exp
}

"""aggregate max on columns"""
type fa2_max_fields {
  contract: String
}

"""aggregate min on columns"""
type fa2_min_fields {
  contract: String
}

"""Ordering options when selecting data from "fa2"."""
input fa2_order_by {
  contract: order_by
  swaps_aggregate: swap_aggregate_order_by
}

"""
select columns of table "fa2"
"""
enum fa2_select_column {
  """column name"""
  contract
}

"""
columns and relationships of "holder"
"""
type holder {
  address: String!
  description: String!
  hdao_balance: bigint!

  """An array relationship"""
  holder_signatures(
    """distinct select on columns"""
    distinct_on: [split_signatures_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_signatures_order_by!]

    """filter the rows returned"""
    where: split_signatures_bool_exp
  ): [split_signatures!]!

  """An aggregate relationship"""
  holder_signatures_aggregate(
    """distinct select on columns"""
    distinct_on: [split_signatures_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_signatures_order_by!]

    """filter the rows returned"""
    where: split_signatures_bool_exp
  ): split_signatures_aggregate!

  """An array relationship"""
  holders_token(
    """distinct select on columns"""
    distinct_on: [token_holder_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_holder_order_by!]

    """filter the rows returned"""
    where: token_holder_bool_exp
  ): [token_holder!]!

  """An aggregate relationship"""
  holders_token_aggregate(
    """distinct select on columns"""
    distinct_on: [token_holder_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_holder_order_by!]

    """filter the rows returned"""
    where: token_holder_bool_exp
  ): token_holder_aggregate!
  is_split: Boolean!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb!
  metadata_file: String!
  name: String!

  """An array relationship"""
  owner(
    """distinct select on columns"""
    distinct_on: [token_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_operator_order_by!]

    """filter the rows returned"""
    where: token_operator_bool_exp
  ): [token_operator!]!

  """An aggregate relationship"""
  owner_aggregate(
    """distinct select on columns"""
    distinct_on: [token_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_operator_order_by!]

    """filter the rows returned"""
    where: token_operator_bool_exp
  ): token_operator_aggregate!

  """An array relationship"""
  purchases(
    """distinct select on columns"""
    distinct_on: [trade_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trade_order_by!]

    """filter the rows returned"""
    where: trade_bool_exp
  ): [trade!]!

  """An aggregate relationship"""
  purchases_aggregate(
    """distinct select on columns"""
    distinct_on: [trade_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trade_order_by!]

    """filter the rows returned"""
    where: trade_bool_exp
  ): trade_aggregate!

  """An array relationship"""
  sales(
    """distinct select on columns"""
    distinct_on: [trade_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trade_order_by!]

    """filter the rows returned"""
    where: trade_bool_exp
  ): [trade!]!

  """An aggregate relationship"""
  sales_aggregate(
    """distinct select on columns"""
    distinct_on: [trade_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trade_order_by!]

    """filter the rows returned"""
    where: trade_bool_exp
  ): trade_aggregate!

  """An array relationship"""
  shareholder(
    """distinct select on columns"""
    distinct_on: [shareholder_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shareholder_order_by!]

    """filter the rows returned"""
    where: shareholder_bool_exp
  ): [shareholder!]!

  """An aggregate relationship"""
  shareholder_aggregate(
    """distinct select on columns"""
    distinct_on: [shareholder_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shareholder_order_by!]

    """filter the rows returned"""
    where: shareholder_bool_exp
  ): shareholder_aggregate!

  """An array relationship"""
  shares(
    """distinct select on columns"""
    distinct_on: [split_contract_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_contract_order_by!]

    """filter the rows returned"""
    where: split_contract_bool_exp
  ): [split_contract!]!

  """An aggregate relationship"""
  shares_aggregate(
    """distinct select on columns"""
    distinct_on: [split_contract_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_contract_order_by!]

    """filter the rows returned"""
    where: split_contract_bool_exp
  ): split_contract_aggregate!

  """An array relationship"""
  swaps(
    """distinct select on columns"""
    distinct_on: [swap_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [swap_order_by!]

    """filter the rows returned"""
    where: swap_bool_exp
  ): [swap!]!

  """An aggregate relationship"""
  swaps_aggregate(
    """distinct select on columns"""
    distinct_on: [swap_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [swap_order_by!]

    """filter the rows returned"""
    where: swap_bool_exp
  ): swap_aggregate!

  """An array relationship"""
  tokens(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """An aggregate relationship"""
  tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): token_aggregate!
}

"""
aggregated selection of "holder"
"""
type holder_aggregate {
  aggregate: holder_aggregate_fields
  nodes: [holder!]!
}

"""
aggregate fields of "holder"
"""
type holder_aggregate_fields {
  avg: holder_avg_fields
  count(columns: [holder_select_column!], distinct: Boolean): Int!
  max: holder_max_fields
  min: holder_min_fields
  stddev: holder_stddev_fields
  stddev_pop: holder_stddev_pop_fields
  stddev_samp: holder_stddev_samp_fields
  sum: holder_sum_fields
  var_pop: holder_var_pop_fields
  var_samp: holder_var_samp_fields
  variance: holder_variance_fields
}

"""aggregate avg on columns"""
type holder_avg_fields {
  hdao_balance: Float
}

"""
Boolean expression to filter rows from the table "holder". All fields are combined with a logical 'AND'.
"""
input holder_bool_exp {
  _and: [holder_bool_exp!]
  _not: holder_bool_exp
  _or: [holder_bool_exp!]
  address: String_comparison_exp
  description: String_comparison_exp
  hdao_balance: bigint_comparison_exp
  holder_signatures: split_signatures_bool_exp
  holders_token: token_holder_bool_exp
  is_split: Boolean_comparison_exp
  metadata: jsonb_comparison_exp
  metadata_file: String_comparison_exp
  name: String_comparison_exp
  owner: token_operator_bool_exp
  purchases: trade_bool_exp
  sales: trade_bool_exp
  shareholder: shareholder_bool_exp
  shares: split_contract_bool_exp
  swaps: swap_bool_exp
  tokens: token_bool_exp
}

"""aggregate max on columns"""
type holder_max_fields {
  address: String
  description: String
  hdao_balance: bigint
  metadata_file: String
  name: String
}

"""aggregate min on columns"""
type holder_min_fields {
  address: String
  description: String
  hdao_balance: bigint
  metadata_file: String
  name: String
}

"""Ordering options when selecting data from "holder"."""
input holder_order_by {
  address: order_by
  description: order_by
  hdao_balance: order_by
  holder_signatures_aggregate: split_signatures_aggregate_order_by
  holders_token_aggregate: token_holder_aggregate_order_by
  is_split: order_by
  metadata: order_by
  metadata_file: order_by
  name: order_by
  owner_aggregate: token_operator_aggregate_order_by
  purchases_aggregate: trade_aggregate_order_by
  sales_aggregate: trade_aggregate_order_by
  shareholder_aggregate: shareholder_aggregate_order_by
  shares_aggregate: split_contract_aggregate_order_by
  swaps_aggregate: swap_aggregate_order_by
  tokens_aggregate: token_aggregate_order_by
}

"""
select columns of table "holder"
"""
enum holder_select_column {
  """column name"""
  address

  """column name"""
  description

  """column name"""
  hdao_balance

  """column name"""
  is_split

  """column name"""
  metadata

  """column name"""
  metadata_file

  """column name"""
  name
}

"""aggregate stddev on columns"""
type holder_stddev_fields {
  hdao_balance: Float
}

"""aggregate stddev_pop on columns"""
type holder_stddev_pop_fields {
  hdao_balance: Float
}

"""aggregate stddev_samp on columns"""
type holder_stddev_samp_fields {
  hdao_balance: Float
}

"""aggregate sum on columns"""
type holder_sum_fields {
  hdao_balance: bigint
}

"""aggregate var_pop on columns"""
type holder_var_pop_fields {
  hdao_balance: Float
}

"""aggregate var_samp on columns"""
type holder_var_samp_fields {
  hdao_balance: Float
}

"""aggregate variance on columns"""
type holder_variance_fields {
  hdao_balance: Float
}

"""
columns and relationships of "ignored_cids"
"""
type ignored_cids {
  cid: String!
}

"""
aggregated selection of "ignored_cids"
"""
type ignored_cids_aggregate {
  aggregate: ignored_cids_aggregate_fields
  nodes: [ignored_cids!]!
}

"""
aggregate fields of "ignored_cids"
"""
type ignored_cids_aggregate_fields {
  count(columns: [ignored_cids_select_column!], distinct: Boolean): Int!
  max: ignored_cids_max_fields
  min: ignored_cids_min_fields
}

"""
Boolean expression to filter rows from the table "ignored_cids". All fields are combined with a logical 'AND'.
"""
input ignored_cids_bool_exp {
  _and: [ignored_cids_bool_exp!]
  _not: ignored_cids_bool_exp
  _or: [ignored_cids_bool_exp!]
  cid: String_comparison_exp
}

"""aggregate max on columns"""
type ignored_cids_max_fields {
  cid: String
}

"""aggregate min on columns"""
type ignored_cids_min_fields {
  cid: String
}

"""Ordering options when selecting data from "ignored_cids"."""
input ignored_cids_order_by {
  cid: order_by
}

"""
select columns of table "ignored_cids"
"""
enum ignored_cids_select_column {
  """column name"""
  cid
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

type query_root {
  """
  fetch data from the table: "dipdup_contract"
  """
  dipdup_contract(
    """distinct select on columns"""
    distinct_on: [dipdup_contract_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_contract_order_by!]

    """filter the rows returned"""
    where: dipdup_contract_bool_exp
  ): [dipdup_contract!]!

  """
  fetch aggregated fields from the table: "dipdup_contract"
  """
  dipdup_contract_aggregate(
    """distinct select on columns"""
    distinct_on: [dipdup_contract_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_contract_order_by!]

    """filter the rows returned"""
    where: dipdup_contract_bool_exp
  ): dipdup_contract_aggregate!

  """fetch data from the table: "dipdup_contract" using primary key columns"""
  dipdup_contract_by_pk(name: String!): dipdup_contract

  """
  fetch data from the table: "dipdup_contract_metadata"
  """
  dipdup_contract_metadata(
    """distinct select on columns"""
    distinct_on: [dipdup_contract_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_contract_metadata_order_by!]

    """filter the rows returned"""
    where: dipdup_contract_metadata_bool_exp
  ): [dipdup_contract_metadata!]!

  """
  fetch aggregated fields from the table: "dipdup_contract_metadata"
  """
  dipdup_contract_metadata_aggregate(
    """distinct select on columns"""
    distinct_on: [dipdup_contract_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_contract_metadata_order_by!]

    """filter the rows returned"""
    where: dipdup_contract_metadata_bool_exp
  ): dipdup_contract_metadata_aggregate!

  """
  fetch data from the table: "dipdup_contract_metadata" using primary key columns
  """
  dipdup_contract_metadata_by_pk(id: Int!): dipdup_contract_metadata

  """
  fetch data from the table: "dipdup_head"
  """
  dipdup_head(
    """distinct select on columns"""
    distinct_on: [dipdup_head_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_head_order_by!]

    """filter the rows returned"""
    where: dipdup_head_bool_exp
  ): [dipdup_head!]!

  """
  fetch aggregated fields from the table: "dipdup_head"
  """
  dipdup_head_aggregate(
    """distinct select on columns"""
    distinct_on: [dipdup_head_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_head_order_by!]

    """filter the rows returned"""
    where: dipdup_head_bool_exp
  ): dipdup_head_aggregate!

  """fetch data from the table: "dipdup_head" using primary key columns"""
  dipdup_head_by_pk(name: String!): dipdup_head

  """
  fetch data from the table: "dipdup_head_status"
  """
  dipdup_head_status(
    """distinct select on columns"""
    distinct_on: [dipdup_head_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_head_status_order_by!]

    """filter the rows returned"""
    where: dipdup_head_status_bool_exp
  ): [dipdup_head_status!]!

  """
  fetch aggregated fields from the table: "dipdup_head_status"
  """
  dipdup_head_status_aggregate(
    """distinct select on columns"""
    distinct_on: [dipdup_head_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_head_status_order_by!]

    """filter the rows returned"""
    where: dipdup_head_status_bool_exp
  ): dipdup_head_status_aggregate!

  """
  fetch data from the table: "dipdup_index"
  """
  dipdup_index(
    """distinct select on columns"""
    distinct_on: [dipdup_index_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_index_order_by!]

    """filter the rows returned"""
    where: dipdup_index_bool_exp
  ): [dipdup_index!]!

  """
  fetch aggregated fields from the table: "dipdup_index"
  """
  dipdup_index_aggregate(
    """distinct select on columns"""
    distinct_on: [dipdup_index_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_index_order_by!]

    """filter the rows returned"""
    where: dipdup_index_bool_exp
  ): dipdup_index_aggregate!

  """fetch data from the table: "dipdup_index" using primary key columns"""
  dipdup_index_by_pk(name: String!): dipdup_index

  """
  fetch data from the table: "dipdup_model_update"
  """
  dipdup_model_update(
    """distinct select on columns"""
    distinct_on: [dipdup_model_update_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_model_update_order_by!]

    """filter the rows returned"""
    where: dipdup_model_update_bool_exp
  ): [dipdup_model_update!]!

  """
  fetch aggregated fields from the table: "dipdup_model_update"
  """
  dipdup_model_update_aggregate(
    """distinct select on columns"""
    distinct_on: [dipdup_model_update_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_model_update_order_by!]

    """filter the rows returned"""
    where: dipdup_model_update_bool_exp
  ): dipdup_model_update_aggregate!

  """
  fetch data from the table: "dipdup_model_update" using primary key columns
  """
  dipdup_model_update_by_pk(id: Int!): dipdup_model_update

  """
  fetch data from the table: "dipdup_schema"
  """
  dipdup_schema(
    """distinct select on columns"""
    distinct_on: [dipdup_schema_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_schema_order_by!]

    """filter the rows returned"""
    where: dipdup_schema_bool_exp
  ): [dipdup_schema!]!

  """
  fetch aggregated fields from the table: "dipdup_schema"
  """
  dipdup_schema_aggregate(
    """distinct select on columns"""
    distinct_on: [dipdup_schema_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_schema_order_by!]

    """filter the rows returned"""
    where: dipdup_schema_bool_exp
  ): dipdup_schema_aggregate!

  """fetch data from the table: "dipdup_schema" using primary key columns"""
  dipdup_schema_by_pk(name: String!): dipdup_schema

  """
  fetch data from the table: "dipdup_token_metadata"
  """
  dipdup_token_metadata(
    """distinct select on columns"""
    distinct_on: [dipdup_token_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_token_metadata_order_by!]

    """filter the rows returned"""
    where: dipdup_token_metadata_bool_exp
  ): [dipdup_token_metadata!]!

  """
  fetch aggregated fields from the table: "dipdup_token_metadata"
  """
  dipdup_token_metadata_aggregate(
    """distinct select on columns"""
    distinct_on: [dipdup_token_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_token_metadata_order_by!]

    """filter the rows returned"""
    where: dipdup_token_metadata_bool_exp
  ): dipdup_token_metadata_aggregate!

  """
  fetch data from the table: "dipdup_token_metadata" using primary key columns
  """
  dipdup_token_metadata_by_pk(id: Int!): dipdup_token_metadata

  """
  fetch data from the table: "fa2"
  """
  fa2(
    """distinct select on columns"""
    distinct_on: [fa2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fa2_order_by!]

    """filter the rows returned"""
    where: fa2_bool_exp
  ): [fa2!]!

  """
  fetch aggregated fields from the table: "fa2"
  """
  fa2_aggregate(
    """distinct select on columns"""
    distinct_on: [fa2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fa2_order_by!]

    """filter the rows returned"""
    where: fa2_bool_exp
  ): fa2_aggregate!

  """fetch data from the table: "fa2" using primary key columns"""
  fa2_by_pk(contract: String!): fa2

  """
  fetch data from the table: "holder"
  """
  holder(
    """distinct select on columns"""
    distinct_on: [holder_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [holder_order_by!]

    """filter the rows returned"""
    where: holder_bool_exp
  ): [holder!]!

  """
  fetch aggregated fields from the table: "holder"
  """
  holder_aggregate(
    """distinct select on columns"""
    distinct_on: [holder_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [holder_order_by!]

    """filter the rows returned"""
    where: holder_bool_exp
  ): holder_aggregate!

  """fetch data from the table: "holder" using primary key columns"""
  holder_by_pk(address: String!): holder

  """
  fetch data from the table: "ignored_cids"
  """
  ignored_cids(
    """distinct select on columns"""
    distinct_on: [ignored_cids_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ignored_cids_order_by!]

    """filter the rows returned"""
    where: ignored_cids_bool_exp
  ): [ignored_cids!]!

  """
  fetch aggregated fields from the table: "ignored_cids"
  """
  ignored_cids_aggregate(
    """distinct select on columns"""
    distinct_on: [ignored_cids_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ignored_cids_order_by!]

    """filter the rows returned"""
    where: ignored_cids_bool_exp
  ): ignored_cids_aggregate!

  """fetch data from the table: "ignored_cids" using primary key columns"""
  ignored_cids_by_pk(cid: String!): ignored_cids

  """An array relationship"""
  shareholder(
    """distinct select on columns"""
    distinct_on: [shareholder_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shareholder_order_by!]

    """filter the rows returned"""
    where: shareholder_bool_exp
  ): [shareholder!]!

  """An aggregate relationship"""
  shareholder_aggregate(
    """distinct select on columns"""
    distinct_on: [shareholder_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shareholder_order_by!]

    """filter the rows returned"""
    where: shareholder_bool_exp
  ): shareholder_aggregate!

  """fetch data from the table: "shareholder" using primary key columns"""
  shareholder_by_pk(id: Int!): shareholder

  """
  fetch data from the table: "split_contract"
  """
  split_contract(
    """distinct select on columns"""
    distinct_on: [split_contract_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_contract_order_by!]

    """filter the rows returned"""
    where: split_contract_bool_exp
  ): [split_contract!]!

  """
  fetch aggregated fields from the table: "split_contract"
  """
  split_contract_aggregate(
    """distinct select on columns"""
    distinct_on: [split_contract_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_contract_order_by!]

    """filter the rows returned"""
    where: split_contract_bool_exp
  ): split_contract_aggregate!

  """fetch data from the table: "split_contract" using primary key columns"""
  split_contract_by_pk(id: Int!): split_contract

  """
  fetch data from the table: "split_signatures"
  """
  split_signatures(
    """distinct select on columns"""
    distinct_on: [split_signatures_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_signatures_order_by!]

    """filter the rows returned"""
    where: split_signatures_bool_exp
  ): [split_signatures!]!

  """
  fetch aggregated fields from the table: "split_signatures"
  """
  split_signatures_aggregate(
    """distinct select on columns"""
    distinct_on: [split_signatures_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_signatures_order_by!]

    """filter the rows returned"""
    where: split_signatures_bool_exp
  ): split_signatures_aggregate!

  """
  fetch data from the table: "split_signatures" using primary key columns
  """
  split_signatures_by_pk(id: Int!): split_signatures

  """
  fetch data from the table: "swap"
  """
  swap(
    """distinct select on columns"""
    distinct_on: [swap_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [swap_order_by!]

    """filter the rows returned"""
    where: swap_bool_exp
  ): [swap!]!

  """
  fetch aggregated fields from the table: "swap"
  """
  swap_aggregate(
    """distinct select on columns"""
    distinct_on: [swap_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [swap_order_by!]

    """filter the rows returned"""
    where: swap_bool_exp
  ): swap_aggregate!

  """fetch data from the table: "swap" using primary key columns"""
  swap_by_pk(opid: bigint!): swap

  """
  fetch data from the table: "tag_model"
  """
  tag_model(
    """distinct select on columns"""
    distinct_on: [tag_model_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_model_order_by!]

    """filter the rows returned"""
    where: tag_model_bool_exp
  ): [tag_model!]!

  """
  fetch aggregated fields from the table: "tag_model"
  """
  tag_model_aggregate(
    """distinct select on columns"""
    distinct_on: [tag_model_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_model_order_by!]

    """filter the rows returned"""
    where: tag_model_bool_exp
  ): tag_model_aggregate!

  """fetch data from the table: "tag_model" using primary key columns"""
  tag_model_by_pk(id: bigint!): tag_model

  """
  fetch data from the table: "token"
  """
  token(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """
  fetch aggregated fields from the table: "token"
  """
  token_aggregate(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): token_aggregate!

  """fetch data from the table: "token" using primary key columns"""
  token_by_pk(id: bigint!): token

  """
  fetch data from the table: "token_holder"
  """
  token_holder(
    """distinct select on columns"""
    distinct_on: [token_holder_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_holder_order_by!]

    """filter the rows returned"""
    where: token_holder_bool_exp
  ): [token_holder!]!

  """
  fetch aggregated fields from the table: "token_holder"
  """
  token_holder_aggregate(
    """distinct select on columns"""
    distinct_on: [token_holder_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_holder_order_by!]

    """filter the rows returned"""
    where: token_holder_bool_exp
  ): token_holder_aggregate!

  """fetch data from the table: "token_holder" using primary key columns"""
  token_holder_by_pk(id: Int!): token_holder

  """
  fetch data from the table: "token_operator"
  """
  token_operator(
    """distinct select on columns"""
    distinct_on: [token_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_operator_order_by!]

    """filter the rows returned"""
    where: token_operator_bool_exp
  ): [token_operator!]!

  """
  fetch aggregated fields from the table: "token_operator"
  """
  token_operator_aggregate(
    """distinct select on columns"""
    distinct_on: [token_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_operator_order_by!]

    """filter the rows returned"""
    where: token_operator_bool_exp
  ): token_operator_aggregate!

  """fetch data from the table: "token_operator" using primary key columns"""
  token_operator_by_pk(id: Int!): token_operator

  """
  fetch data from the table: "token_tag"
  """
  token_tag(
    """distinct select on columns"""
    distinct_on: [token_tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_tag_order_by!]

    """filter the rows returned"""
    where: token_tag_bool_exp
  ): [token_tag!]!

  """
  fetch aggregated fields from the table: "token_tag"
  """
  token_tag_aggregate(
    """distinct select on columns"""
    distinct_on: [token_tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_tag_order_by!]

    """filter the rows returned"""
    where: token_tag_bool_exp
  ): token_tag_aggregate!

  """fetch data from the table: "token_tag" using primary key columns"""
  token_tag_by_pk(id: Int!): token_tag

  """
  fetch data from the table: "trade"
  """
  trade(
    """distinct select on columns"""
    distinct_on: [trade_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trade_order_by!]

    """filter the rows returned"""
    where: trade_bool_exp
  ): [trade!]!

  """
  fetch aggregated fields from the table: "trade"
  """
  trade_aggregate(
    """distinct select on columns"""
    distinct_on: [trade_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trade_order_by!]

    """filter the rows returned"""
    where: trade_bool_exp
  ): trade_aggregate!

  """fetch data from the table: "trade" using primary key columns"""
  trade_by_pk(id: bigint!): trade
}

"""
columns and relationships of "shareholder"
"""
type shareholder {
  """An object relationship"""
  holder: holder!
  holder_id: String!

  """
  unspecified: unspecified\ncore_participant: core_participant\nbenefactor: benefactor
  """
  holder_type: String!
  id: Int!
  shares: bigint!

  """An object relationship"""
  split_contract: split_contract!
  split_contract_id: Int!
}

"""
aggregated selection of "shareholder"
"""
type shareholder_aggregate {
  aggregate: shareholder_aggregate_fields
  nodes: [shareholder!]!
}

"""
aggregate fields of "shareholder"
"""
type shareholder_aggregate_fields {
  avg: shareholder_avg_fields
  count(columns: [shareholder_select_column!], distinct: Boolean): Int!
  max: shareholder_max_fields
  min: shareholder_min_fields
  stddev: shareholder_stddev_fields
  stddev_pop: shareholder_stddev_pop_fields
  stddev_samp: shareholder_stddev_samp_fields
  sum: shareholder_sum_fields
  var_pop: shareholder_var_pop_fields
  var_samp: shareholder_var_samp_fields
  variance: shareholder_variance_fields
}

"""
order by aggregate values of table "shareholder"
"""
input shareholder_aggregate_order_by {
  avg: shareholder_avg_order_by
  count: order_by
  max: shareholder_max_order_by
  min: shareholder_min_order_by
  stddev: shareholder_stddev_order_by
  stddev_pop: shareholder_stddev_pop_order_by
  stddev_samp: shareholder_stddev_samp_order_by
  sum: shareholder_sum_order_by
  var_pop: shareholder_var_pop_order_by
  var_samp: shareholder_var_samp_order_by
  variance: shareholder_variance_order_by
}

"""aggregate avg on columns"""
type shareholder_avg_fields {
  id: Float
  shares: Float
  split_contract_id: Float
}

"""
order by avg() on columns of table "shareholder"
"""
input shareholder_avg_order_by {
  id: order_by
  shares: order_by
  split_contract_id: order_by
}

"""
Boolean expression to filter rows from the table "shareholder". All fields are combined with a logical 'AND'.
"""
input shareholder_bool_exp {
  _and: [shareholder_bool_exp!]
  _not: shareholder_bool_exp
  _or: [shareholder_bool_exp!]
  holder: holder_bool_exp
  holder_id: String_comparison_exp
  holder_type: String_comparison_exp
  id: Int_comparison_exp
  shares: bigint_comparison_exp
  split_contract: split_contract_bool_exp
  split_contract_id: Int_comparison_exp
}

"""aggregate max on columns"""
type shareholder_max_fields {
  holder_id: String

  """
  unspecified: unspecified\ncore_participant: core_participant\nbenefactor: benefactor
  """
  holder_type: String
  id: Int
  shares: bigint
  split_contract_id: Int
}

"""
order by max() on columns of table "shareholder"
"""
input shareholder_max_order_by {
  holder_id: order_by

  """
  unspecified: unspecified\ncore_participant: core_participant\nbenefactor: benefactor
  """
  holder_type: order_by
  id: order_by
  shares: order_by
  split_contract_id: order_by
}

"""aggregate min on columns"""
type shareholder_min_fields {
  holder_id: String

  """
  unspecified: unspecified\ncore_participant: core_participant\nbenefactor: benefactor
  """
  holder_type: String
  id: Int
  shares: bigint
  split_contract_id: Int
}

"""
order by min() on columns of table "shareholder"
"""
input shareholder_min_order_by {
  holder_id: order_by

  """
  unspecified: unspecified\ncore_participant: core_participant\nbenefactor: benefactor
  """
  holder_type: order_by
  id: order_by
  shares: order_by
  split_contract_id: order_by
}

"""Ordering options when selecting data from "shareholder"."""
input shareholder_order_by {
  holder: holder_order_by
  holder_id: order_by
  holder_type: order_by
  id: order_by
  shares: order_by
  split_contract: split_contract_order_by
  split_contract_id: order_by
}

"""
select columns of table "shareholder"
"""
enum shareholder_select_column {
  """column name"""
  holder_id

  """column name"""
  holder_type

  """column name"""
  id

  """column name"""
  shares

  """column name"""
  split_contract_id
}

"""aggregate stddev on columns"""
type shareholder_stddev_fields {
  id: Float
  shares: Float
  split_contract_id: Float
}

"""
order by stddev() on columns of table "shareholder"
"""
input shareholder_stddev_order_by {
  id: order_by
  shares: order_by
  split_contract_id: order_by
}

"""aggregate stddev_pop on columns"""
type shareholder_stddev_pop_fields {
  id: Float
  shares: Float
  split_contract_id: Float
}

"""
order by stddev_pop() on columns of table "shareholder"
"""
input shareholder_stddev_pop_order_by {
  id: order_by
  shares: order_by
  split_contract_id: order_by
}

"""aggregate stddev_samp on columns"""
type shareholder_stddev_samp_fields {
  id: Float
  shares: Float
  split_contract_id: Float
}

"""
order by stddev_samp() on columns of table "shareholder"
"""
input shareholder_stddev_samp_order_by {
  id: order_by
  shares: order_by
  split_contract_id: order_by
}

"""aggregate sum on columns"""
type shareholder_sum_fields {
  id: Int
  shares: bigint
  split_contract_id: Int
}

"""
order by sum() on columns of table "shareholder"
"""
input shareholder_sum_order_by {
  id: order_by
  shares: order_by
  split_contract_id: order_by
}

"""aggregate var_pop on columns"""
type shareholder_var_pop_fields {
  id: Float
  shares: Float
  split_contract_id: Float
}

"""
order by var_pop() on columns of table "shareholder"
"""
input shareholder_var_pop_order_by {
  id: order_by
  shares: order_by
  split_contract_id: order_by
}

"""aggregate var_samp on columns"""
type shareholder_var_samp_fields {
  id: Float
  shares: Float
  split_contract_id: Float
}

"""
order by var_samp() on columns of table "shareholder"
"""
input shareholder_var_samp_order_by {
  id: order_by
  shares: order_by
  split_contract_id: order_by
}

"""aggregate variance on columns"""
type shareholder_variance_fields {
  id: Float
  shares: Float
  split_contract_id: Float
}

"""
order by variance() on columns of table "shareholder"
"""
input shareholder_variance_order_by {
  id: order_by
  shares: order_by
  split_contract_id: order_by
}

scalar smallint

"""
Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'.
"""
input smallint_comparison_exp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _is_null: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

"""
columns and relationships of "split_contract"
"""
type split_contract {
  administrator: String

  """An object relationship"""
  contract: holder!
  contract_id: String!
  id: Int!

  """An array relationship"""
  shareholder(
    """distinct select on columns"""
    distinct_on: [shareholder_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shareholder_order_by!]

    """filter the rows returned"""
    where: shareholder_bool_exp
  ): [shareholder!]!

  """An aggregate relationship"""
  shareholder_aggregate(
    """distinct select on columns"""
    distinct_on: [shareholder_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shareholder_order_by!]

    """filter the rows returned"""
    where: shareholder_bool_exp
  ): shareholder_aggregate!
  total_shares: bigint
}

"""
aggregated selection of "split_contract"
"""
type split_contract_aggregate {
  aggregate: split_contract_aggregate_fields
  nodes: [split_contract!]!
}

"""
aggregate fields of "split_contract"
"""
type split_contract_aggregate_fields {
  avg: split_contract_avg_fields
  count(columns: [split_contract_select_column!], distinct: Boolean): Int!
  max: split_contract_max_fields
  min: split_contract_min_fields
  stddev: split_contract_stddev_fields
  stddev_pop: split_contract_stddev_pop_fields
  stddev_samp: split_contract_stddev_samp_fields
  sum: split_contract_sum_fields
  var_pop: split_contract_var_pop_fields
  var_samp: split_contract_var_samp_fields
  variance: split_contract_variance_fields
}

"""
order by aggregate values of table "split_contract"
"""
input split_contract_aggregate_order_by {
  avg: split_contract_avg_order_by
  count: order_by
  max: split_contract_max_order_by
  min: split_contract_min_order_by
  stddev: split_contract_stddev_order_by
  stddev_pop: split_contract_stddev_pop_order_by
  stddev_samp: split_contract_stddev_samp_order_by
  sum: split_contract_sum_order_by
  var_pop: split_contract_var_pop_order_by
  var_samp: split_contract_var_samp_order_by
  variance: split_contract_variance_order_by
}

"""aggregate avg on columns"""
type split_contract_avg_fields {
  id: Float
  total_shares: Float
}

"""
order by avg() on columns of table "split_contract"
"""
input split_contract_avg_order_by {
  id: order_by
  total_shares: order_by
}

"""
Boolean expression to filter rows from the table "split_contract". All fields are combined with a logical 'AND'.
"""
input split_contract_bool_exp {
  _and: [split_contract_bool_exp!]
  _not: split_contract_bool_exp
  _or: [split_contract_bool_exp!]
  administrator: String_comparison_exp
  contract: holder_bool_exp
  contract_id: String_comparison_exp
  id: Int_comparison_exp
  shareholder: shareholder_bool_exp
  total_shares: bigint_comparison_exp
}

"""aggregate max on columns"""
type split_contract_max_fields {
  administrator: String
  contract_id: String
  id: Int
  total_shares: bigint
}

"""
order by max() on columns of table "split_contract"
"""
input split_contract_max_order_by {
  administrator: order_by
  contract_id: order_by
  id: order_by
  total_shares: order_by
}

"""aggregate min on columns"""
type split_contract_min_fields {
  administrator: String
  contract_id: String
  id: Int
  total_shares: bigint
}

"""
order by min() on columns of table "split_contract"
"""
input split_contract_min_order_by {
  administrator: order_by
  contract_id: order_by
  id: order_by
  total_shares: order_by
}

"""Ordering options when selecting data from "split_contract"."""
input split_contract_order_by {
  administrator: order_by
  contract: holder_order_by
  contract_id: order_by
  id: order_by
  shareholder_aggregate: shareholder_aggregate_order_by
  total_shares: order_by
}

"""
select columns of table "split_contract"
"""
enum split_contract_select_column {
  """column name"""
  administrator

  """column name"""
  contract_id

  """column name"""
  id

  """column name"""
  total_shares
}

"""aggregate stddev on columns"""
type split_contract_stddev_fields {
  id: Float
  total_shares: Float
}

"""
order by stddev() on columns of table "split_contract"
"""
input split_contract_stddev_order_by {
  id: order_by
  total_shares: order_by
}

"""aggregate stddev_pop on columns"""
type split_contract_stddev_pop_fields {
  id: Float
  total_shares: Float
}

"""
order by stddev_pop() on columns of table "split_contract"
"""
input split_contract_stddev_pop_order_by {
  id: order_by
  total_shares: order_by
}

"""aggregate stddev_samp on columns"""
type split_contract_stddev_samp_fields {
  id: Float
  total_shares: Float
}

"""
order by stddev_samp() on columns of table "split_contract"
"""
input split_contract_stddev_samp_order_by {
  id: order_by
  total_shares: order_by
}

"""aggregate sum on columns"""
type split_contract_sum_fields {
  id: Int
  total_shares: bigint
}

"""
order by sum() on columns of table "split_contract"
"""
input split_contract_sum_order_by {
  id: order_by
  total_shares: order_by
}

"""aggregate var_pop on columns"""
type split_contract_var_pop_fields {
  id: Float
  total_shares: Float
}

"""
order by var_pop() on columns of table "split_contract"
"""
input split_contract_var_pop_order_by {
  id: order_by
  total_shares: order_by
}

"""aggregate var_samp on columns"""
type split_contract_var_samp_fields {
  id: Float
  total_shares: Float
}

"""
order by var_samp() on columns of table "split_contract"
"""
input split_contract_var_samp_order_by {
  id: order_by
  total_shares: order_by
}

"""aggregate variance on columns"""
type split_contract_variance_fields {
  id: Float
  total_shares: Float
}

"""
order by variance() on columns of table "split_contract"
"""
input split_contract_variance_order_by {
  id: order_by
  total_shares: order_by
}

"""
columns and relationships of "split_signatures"
"""
type split_signatures {
  """An object relationship"""
  holder: holder!
  holder_id: String!
  id: Int!

  """An object relationship"""
  token: token!
  token_id: bigint!
}

"""
aggregated selection of "split_signatures"
"""
type split_signatures_aggregate {
  aggregate: split_signatures_aggregate_fields
  nodes: [split_signatures!]!
}

"""
aggregate fields of "split_signatures"
"""
type split_signatures_aggregate_fields {
  avg: split_signatures_avg_fields
  count(columns: [split_signatures_select_column!], distinct: Boolean): Int!
  max: split_signatures_max_fields
  min: split_signatures_min_fields
  stddev: split_signatures_stddev_fields
  stddev_pop: split_signatures_stddev_pop_fields
  stddev_samp: split_signatures_stddev_samp_fields
  sum: split_signatures_sum_fields
  var_pop: split_signatures_var_pop_fields
  var_samp: split_signatures_var_samp_fields
  variance: split_signatures_variance_fields
}

"""
order by aggregate values of table "split_signatures"
"""
input split_signatures_aggregate_order_by {
  avg: split_signatures_avg_order_by
  count: order_by
  max: split_signatures_max_order_by
  min: split_signatures_min_order_by
  stddev: split_signatures_stddev_order_by
  stddev_pop: split_signatures_stddev_pop_order_by
  stddev_samp: split_signatures_stddev_samp_order_by
  sum: split_signatures_sum_order_by
  var_pop: split_signatures_var_pop_order_by
  var_samp: split_signatures_var_samp_order_by
  variance: split_signatures_variance_order_by
}

"""aggregate avg on columns"""
type split_signatures_avg_fields {
  id: Float
  token_id: Float
}

"""
order by avg() on columns of table "split_signatures"
"""
input split_signatures_avg_order_by {
  id: order_by
  token_id: order_by
}

"""
Boolean expression to filter rows from the table "split_signatures". All fields are combined with a logical 'AND'.
"""
input split_signatures_bool_exp {
  _and: [split_signatures_bool_exp!]
  _not: split_signatures_bool_exp
  _or: [split_signatures_bool_exp!]
  holder: holder_bool_exp
  holder_id: String_comparison_exp
  id: Int_comparison_exp
  token: token_bool_exp
  token_id: bigint_comparison_exp
}

"""aggregate max on columns"""
type split_signatures_max_fields {
  holder_id: String
  id: Int
  token_id: bigint
}

"""
order by max() on columns of table "split_signatures"
"""
input split_signatures_max_order_by {
  holder_id: order_by
  id: order_by
  token_id: order_by
}

"""aggregate min on columns"""
type split_signatures_min_fields {
  holder_id: String
  id: Int
  token_id: bigint
}

"""
order by min() on columns of table "split_signatures"
"""
input split_signatures_min_order_by {
  holder_id: order_by
  id: order_by
  token_id: order_by
}

"""Ordering options when selecting data from "split_signatures"."""
input split_signatures_order_by {
  holder: holder_order_by
  holder_id: order_by
  id: order_by
  token: token_order_by
  token_id: order_by
}

"""
select columns of table "split_signatures"
"""
enum split_signatures_select_column {
  """column name"""
  holder_id

  """column name"""
  id

  """column name"""
  token_id
}

"""aggregate stddev on columns"""
type split_signatures_stddev_fields {
  id: Float
  token_id: Float
}

"""
order by stddev() on columns of table "split_signatures"
"""
input split_signatures_stddev_order_by {
  id: order_by
  token_id: order_by
}

"""aggregate stddev_pop on columns"""
type split_signatures_stddev_pop_fields {
  id: Float
  token_id: Float
}

"""
order by stddev_pop() on columns of table "split_signatures"
"""
input split_signatures_stddev_pop_order_by {
  id: order_by
  token_id: order_by
}

"""aggregate stddev_samp on columns"""
type split_signatures_stddev_samp_fields {
  id: Float
  token_id: Float
}

"""
order by stddev_samp() on columns of table "split_signatures"
"""
input split_signatures_stddev_samp_order_by {
  id: order_by
  token_id: order_by
}

"""aggregate sum on columns"""
type split_signatures_sum_fields {
  id: Int
  token_id: bigint
}

"""
order by sum() on columns of table "split_signatures"
"""
input split_signatures_sum_order_by {
  id: order_by
  token_id: order_by
}

"""aggregate var_pop on columns"""
type split_signatures_var_pop_fields {
  id: Float
  token_id: Float
}

"""
order by var_pop() on columns of table "split_signatures"
"""
input split_signatures_var_pop_order_by {
  id: order_by
  token_id: order_by
}

"""aggregate var_samp on columns"""
type split_signatures_var_samp_fields {
  id: Float
  token_id: Float
}

"""
order by var_samp() on columns of table "split_signatures"
"""
input split_signatures_var_samp_order_by {
  id: order_by
  token_id: order_by
}

"""aggregate variance on columns"""
type split_signatures_variance_fields {
  id: Float
  token_id: Float
}

"""
order by variance() on columns of table "split_signatures"
"""
input split_signatures_variance_order_by {
  id: order_by
  token_id: order_by
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

type subscription_root {
  """
  fetch data from the table: "dipdup_contract"
  """
  dipdup_contract(
    """distinct select on columns"""
    distinct_on: [dipdup_contract_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_contract_order_by!]

    """filter the rows returned"""
    where: dipdup_contract_bool_exp
  ): [dipdup_contract!]!

  """
  fetch aggregated fields from the table: "dipdup_contract"
  """
  dipdup_contract_aggregate(
    """distinct select on columns"""
    distinct_on: [dipdup_contract_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_contract_order_by!]

    """filter the rows returned"""
    where: dipdup_contract_bool_exp
  ): dipdup_contract_aggregate!

  """fetch data from the table: "dipdup_contract" using primary key columns"""
  dipdup_contract_by_pk(name: String!): dipdup_contract

  """
  fetch data from the table: "dipdup_contract_metadata"
  """
  dipdup_contract_metadata(
    """distinct select on columns"""
    distinct_on: [dipdup_contract_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_contract_metadata_order_by!]

    """filter the rows returned"""
    where: dipdup_contract_metadata_bool_exp
  ): [dipdup_contract_metadata!]!

  """
  fetch aggregated fields from the table: "dipdup_contract_metadata"
  """
  dipdup_contract_metadata_aggregate(
    """distinct select on columns"""
    distinct_on: [dipdup_contract_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_contract_metadata_order_by!]

    """filter the rows returned"""
    where: dipdup_contract_metadata_bool_exp
  ): dipdup_contract_metadata_aggregate!

  """
  fetch data from the table: "dipdup_contract_metadata" using primary key columns
  """
  dipdup_contract_metadata_by_pk(id: Int!): dipdup_contract_metadata

  """
  fetch data from the table: "dipdup_head"
  """
  dipdup_head(
    """distinct select on columns"""
    distinct_on: [dipdup_head_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_head_order_by!]

    """filter the rows returned"""
    where: dipdup_head_bool_exp
  ): [dipdup_head!]!

  """
  fetch aggregated fields from the table: "dipdup_head"
  """
  dipdup_head_aggregate(
    """distinct select on columns"""
    distinct_on: [dipdup_head_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_head_order_by!]

    """filter the rows returned"""
    where: dipdup_head_bool_exp
  ): dipdup_head_aggregate!

  """fetch data from the table: "dipdup_head" using primary key columns"""
  dipdup_head_by_pk(name: String!): dipdup_head

  """
  fetch data from the table: "dipdup_head_status"
  """
  dipdup_head_status(
    """distinct select on columns"""
    distinct_on: [dipdup_head_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_head_status_order_by!]

    """filter the rows returned"""
    where: dipdup_head_status_bool_exp
  ): [dipdup_head_status!]!

  """
  fetch aggregated fields from the table: "dipdup_head_status"
  """
  dipdup_head_status_aggregate(
    """distinct select on columns"""
    distinct_on: [dipdup_head_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_head_status_order_by!]

    """filter the rows returned"""
    where: dipdup_head_status_bool_exp
  ): dipdup_head_status_aggregate!

  """
  fetch data from the table: "dipdup_index"
  """
  dipdup_index(
    """distinct select on columns"""
    distinct_on: [dipdup_index_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_index_order_by!]

    """filter the rows returned"""
    where: dipdup_index_bool_exp
  ): [dipdup_index!]!

  """
  fetch aggregated fields from the table: "dipdup_index"
  """
  dipdup_index_aggregate(
    """distinct select on columns"""
    distinct_on: [dipdup_index_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_index_order_by!]

    """filter the rows returned"""
    where: dipdup_index_bool_exp
  ): dipdup_index_aggregate!

  """fetch data from the table: "dipdup_index" using primary key columns"""
  dipdup_index_by_pk(name: String!): dipdup_index

  """
  fetch data from the table: "dipdup_model_update"
  """
  dipdup_model_update(
    """distinct select on columns"""
    distinct_on: [dipdup_model_update_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_model_update_order_by!]

    """filter the rows returned"""
    where: dipdup_model_update_bool_exp
  ): [dipdup_model_update!]!

  """
  fetch aggregated fields from the table: "dipdup_model_update"
  """
  dipdup_model_update_aggregate(
    """distinct select on columns"""
    distinct_on: [dipdup_model_update_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_model_update_order_by!]

    """filter the rows returned"""
    where: dipdup_model_update_bool_exp
  ): dipdup_model_update_aggregate!

  """
  fetch data from the table: "dipdup_model_update" using primary key columns
  """
  dipdup_model_update_by_pk(id: Int!): dipdup_model_update

  """
  fetch data from the table: "dipdup_schema"
  """
  dipdup_schema(
    """distinct select on columns"""
    distinct_on: [dipdup_schema_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_schema_order_by!]

    """filter the rows returned"""
    where: dipdup_schema_bool_exp
  ): [dipdup_schema!]!

  """
  fetch aggregated fields from the table: "dipdup_schema"
  """
  dipdup_schema_aggregate(
    """distinct select on columns"""
    distinct_on: [dipdup_schema_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_schema_order_by!]

    """filter the rows returned"""
    where: dipdup_schema_bool_exp
  ): dipdup_schema_aggregate!

  """fetch data from the table: "dipdup_schema" using primary key columns"""
  dipdup_schema_by_pk(name: String!): dipdup_schema

  """
  fetch data from the table: "dipdup_token_metadata"
  """
  dipdup_token_metadata(
    """distinct select on columns"""
    distinct_on: [dipdup_token_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_token_metadata_order_by!]

    """filter the rows returned"""
    where: dipdup_token_metadata_bool_exp
  ): [dipdup_token_metadata!]!

  """
  fetch aggregated fields from the table: "dipdup_token_metadata"
  """
  dipdup_token_metadata_aggregate(
    """distinct select on columns"""
    distinct_on: [dipdup_token_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dipdup_token_metadata_order_by!]

    """filter the rows returned"""
    where: dipdup_token_metadata_bool_exp
  ): dipdup_token_metadata_aggregate!

  """
  fetch data from the table: "dipdup_token_metadata" using primary key columns
  """
  dipdup_token_metadata_by_pk(id: Int!): dipdup_token_metadata

  """
  fetch data from the table: "fa2"
  """
  fa2(
    """distinct select on columns"""
    distinct_on: [fa2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fa2_order_by!]

    """filter the rows returned"""
    where: fa2_bool_exp
  ): [fa2!]!

  """
  fetch aggregated fields from the table: "fa2"
  """
  fa2_aggregate(
    """distinct select on columns"""
    distinct_on: [fa2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fa2_order_by!]

    """filter the rows returned"""
    where: fa2_bool_exp
  ): fa2_aggregate!

  """fetch data from the table: "fa2" using primary key columns"""
  fa2_by_pk(contract: String!): fa2

  """
  fetch data from the table: "holder"
  """
  holder(
    """distinct select on columns"""
    distinct_on: [holder_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [holder_order_by!]

    """filter the rows returned"""
    where: holder_bool_exp
  ): [holder!]!

  """
  fetch aggregated fields from the table: "holder"
  """
  holder_aggregate(
    """distinct select on columns"""
    distinct_on: [holder_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [holder_order_by!]

    """filter the rows returned"""
    where: holder_bool_exp
  ): holder_aggregate!

  """fetch data from the table: "holder" using primary key columns"""
  holder_by_pk(address: String!): holder

  """
  fetch data from the table: "ignored_cids"
  """
  ignored_cids(
    """distinct select on columns"""
    distinct_on: [ignored_cids_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ignored_cids_order_by!]

    """filter the rows returned"""
    where: ignored_cids_bool_exp
  ): [ignored_cids!]!

  """
  fetch aggregated fields from the table: "ignored_cids"
  """
  ignored_cids_aggregate(
    """distinct select on columns"""
    distinct_on: [ignored_cids_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ignored_cids_order_by!]

    """filter the rows returned"""
    where: ignored_cids_bool_exp
  ): ignored_cids_aggregate!

  """fetch data from the table: "ignored_cids" using primary key columns"""
  ignored_cids_by_pk(cid: String!): ignored_cids

  """An array relationship"""
  shareholder(
    """distinct select on columns"""
    distinct_on: [shareholder_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shareholder_order_by!]

    """filter the rows returned"""
    where: shareholder_bool_exp
  ): [shareholder!]!

  """An aggregate relationship"""
  shareholder_aggregate(
    """distinct select on columns"""
    distinct_on: [shareholder_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shareholder_order_by!]

    """filter the rows returned"""
    where: shareholder_bool_exp
  ): shareholder_aggregate!

  """fetch data from the table: "shareholder" using primary key columns"""
  shareholder_by_pk(id: Int!): shareholder

  """
  fetch data from the table: "split_contract"
  """
  split_contract(
    """distinct select on columns"""
    distinct_on: [split_contract_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_contract_order_by!]

    """filter the rows returned"""
    where: split_contract_bool_exp
  ): [split_contract!]!

  """
  fetch aggregated fields from the table: "split_contract"
  """
  split_contract_aggregate(
    """distinct select on columns"""
    distinct_on: [split_contract_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_contract_order_by!]

    """filter the rows returned"""
    where: split_contract_bool_exp
  ): split_contract_aggregate!

  """fetch data from the table: "split_contract" using primary key columns"""
  split_contract_by_pk(id: Int!): split_contract

  """
  fetch data from the table: "split_signatures"
  """
  split_signatures(
    """distinct select on columns"""
    distinct_on: [split_signatures_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_signatures_order_by!]

    """filter the rows returned"""
    where: split_signatures_bool_exp
  ): [split_signatures!]!

  """
  fetch aggregated fields from the table: "split_signatures"
  """
  split_signatures_aggregate(
    """distinct select on columns"""
    distinct_on: [split_signatures_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_signatures_order_by!]

    """filter the rows returned"""
    where: split_signatures_bool_exp
  ): split_signatures_aggregate!

  """
  fetch data from the table: "split_signatures" using primary key columns
  """
  split_signatures_by_pk(id: Int!): split_signatures

  """
  fetch data from the table: "swap"
  """
  swap(
    """distinct select on columns"""
    distinct_on: [swap_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [swap_order_by!]

    """filter the rows returned"""
    where: swap_bool_exp
  ): [swap!]!

  """
  fetch aggregated fields from the table: "swap"
  """
  swap_aggregate(
    """distinct select on columns"""
    distinct_on: [swap_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [swap_order_by!]

    """filter the rows returned"""
    where: swap_bool_exp
  ): swap_aggregate!

  """fetch data from the table: "swap" using primary key columns"""
  swap_by_pk(opid: bigint!): swap

  """
  fetch data from the table: "tag_model"
  """
  tag_model(
    """distinct select on columns"""
    distinct_on: [tag_model_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_model_order_by!]

    """filter the rows returned"""
    where: tag_model_bool_exp
  ): [tag_model!]!

  """
  fetch aggregated fields from the table: "tag_model"
  """
  tag_model_aggregate(
    """distinct select on columns"""
    distinct_on: [tag_model_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_model_order_by!]

    """filter the rows returned"""
    where: tag_model_bool_exp
  ): tag_model_aggregate!

  """fetch data from the table: "tag_model" using primary key columns"""
  tag_model_by_pk(id: bigint!): tag_model

  """
  fetch data from the table: "token"
  """
  token(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """
  fetch aggregated fields from the table: "token"
  """
  token_aggregate(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): token_aggregate!

  """fetch data from the table: "token" using primary key columns"""
  token_by_pk(id: bigint!): token

  """
  fetch data from the table: "token_holder"
  """
  token_holder(
    """distinct select on columns"""
    distinct_on: [token_holder_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_holder_order_by!]

    """filter the rows returned"""
    where: token_holder_bool_exp
  ): [token_holder!]!

  """
  fetch aggregated fields from the table: "token_holder"
  """
  token_holder_aggregate(
    """distinct select on columns"""
    distinct_on: [token_holder_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_holder_order_by!]

    """filter the rows returned"""
    where: token_holder_bool_exp
  ): token_holder_aggregate!

  """fetch data from the table: "token_holder" using primary key columns"""
  token_holder_by_pk(id: Int!): token_holder

  """
  fetch data from the table: "token_operator"
  """
  token_operator(
    """distinct select on columns"""
    distinct_on: [token_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_operator_order_by!]

    """filter the rows returned"""
    where: token_operator_bool_exp
  ): [token_operator!]!

  """
  fetch aggregated fields from the table: "token_operator"
  """
  token_operator_aggregate(
    """distinct select on columns"""
    distinct_on: [token_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_operator_order_by!]

    """filter the rows returned"""
    where: token_operator_bool_exp
  ): token_operator_aggregate!

  """fetch data from the table: "token_operator" using primary key columns"""
  token_operator_by_pk(id: Int!): token_operator

  """
  fetch data from the table: "token_tag"
  """
  token_tag(
    """distinct select on columns"""
    distinct_on: [token_tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_tag_order_by!]

    """filter the rows returned"""
    where: token_tag_bool_exp
  ): [token_tag!]!

  """
  fetch aggregated fields from the table: "token_tag"
  """
  token_tag_aggregate(
    """distinct select on columns"""
    distinct_on: [token_tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_tag_order_by!]

    """filter the rows returned"""
    where: token_tag_bool_exp
  ): token_tag_aggregate!

  """fetch data from the table: "token_tag" using primary key columns"""
  token_tag_by_pk(id: Int!): token_tag

  """
  fetch data from the table: "trade"
  """
  trade(
    """distinct select on columns"""
    distinct_on: [trade_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trade_order_by!]

    """filter the rows returned"""
    where: trade_bool_exp
  ): [trade!]!

  """
  fetch aggregated fields from the table: "trade"
  """
  trade_aggregate(
    """distinct select on columns"""
    distinct_on: [trade_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trade_order_by!]

    """filter the rows returned"""
    where: trade_bool_exp
  ): trade_aggregate!

  """fetch data from the table: "trade" using primary key columns"""
  trade_by_pk(id: bigint!): trade
}

"""
columns and relationships of "swap"
"""
type swap {
  amount: smallint!
  amount_left: smallint!
  contract_address: String!
  contract_version: smallint!

  """An object relationship"""
  creator: holder!
  creator_id: String!

  """An object relationship"""
  fa2: fa2!
  fa2_id: String!
  id: bigint!
  is_valid: Boolean!
  level: bigint!
  ophash: String!
  opid: bigint!
  price: bigint!
  royalties: smallint!

  """ACTIVE: 0\nFINISHED: 1\nCANCELED: 2"""
  status: smallint!
  timestamp: timestamptz!

  """An object relationship"""
  token: token!
  token_id: bigint!

  """An array relationship"""
  trades(
    """distinct select on columns"""
    distinct_on: [trade_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trade_order_by!]

    """filter the rows returned"""
    where: trade_bool_exp
  ): [trade!]!

  """An aggregate relationship"""
  trades_aggregate(
    """distinct select on columns"""
    distinct_on: [trade_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trade_order_by!]

    """filter the rows returned"""
    where: trade_bool_exp
  ): trade_aggregate!
}

"""
aggregated selection of "swap"
"""
type swap_aggregate {
  aggregate: swap_aggregate_fields
  nodes: [swap!]!
}

"""
aggregate fields of "swap"
"""
type swap_aggregate_fields {
  avg: swap_avg_fields
  count(columns: [swap_select_column!], distinct: Boolean): Int!
  max: swap_max_fields
  min: swap_min_fields
  stddev: swap_stddev_fields
  stddev_pop: swap_stddev_pop_fields
  stddev_samp: swap_stddev_samp_fields
  sum: swap_sum_fields
  var_pop: swap_var_pop_fields
  var_samp: swap_var_samp_fields
  variance: swap_variance_fields
}

"""
order by aggregate values of table "swap"
"""
input swap_aggregate_order_by {
  avg: swap_avg_order_by
  count: order_by
  max: swap_max_order_by
  min: swap_min_order_by
  stddev: swap_stddev_order_by
  stddev_pop: swap_stddev_pop_order_by
  stddev_samp: swap_stddev_samp_order_by
  sum: swap_sum_order_by
  var_pop: swap_var_pop_order_by
  var_samp: swap_var_samp_order_by
  variance: swap_variance_order_by
}

"""aggregate avg on columns"""
type swap_avg_fields {
  amount: Float
  amount_left: Float
  contract_version: Float
  id: Float
  level: Float
  opid: Float
  price: Float
  royalties: Float

  """ACTIVE: 0\nFINISHED: 1\nCANCELED: 2"""
  status: Float
  token_id: Float
}

"""
order by avg() on columns of table "swap"
"""
input swap_avg_order_by {
  amount: order_by
  amount_left: order_by
  contract_version: order_by
  id: order_by
  level: order_by
  opid: order_by
  price: order_by
  royalties: order_by

  """ACTIVE: 0\nFINISHED: 1\nCANCELED: 2"""
  status: order_by
  token_id: order_by
}

"""
Boolean expression to filter rows from the table "swap". All fields are combined with a logical 'AND'.
"""
input swap_bool_exp {
  _and: [swap_bool_exp!]
  _not: swap_bool_exp
  _or: [swap_bool_exp!]
  amount: smallint_comparison_exp
  amount_left: smallint_comparison_exp
  contract_address: String_comparison_exp
  contract_version: smallint_comparison_exp
  creator: holder_bool_exp
  creator_id: String_comparison_exp
  fa2: fa2_bool_exp
  fa2_id: String_comparison_exp
  id: bigint_comparison_exp
  is_valid: Boolean_comparison_exp
  level: bigint_comparison_exp
  ophash: String_comparison_exp
  opid: bigint_comparison_exp
  price: bigint_comparison_exp
  royalties: smallint_comparison_exp
  status: smallint_comparison_exp
  timestamp: timestamptz_comparison_exp
  token: token_bool_exp
  token_id: bigint_comparison_exp
  trades: trade_bool_exp
}

"""aggregate max on columns"""
type swap_max_fields {
  amount: smallint
  amount_left: smallint
  contract_address: String
  contract_version: smallint
  creator_id: String
  fa2_id: String
  id: bigint
  level: bigint
  ophash: String
  opid: bigint
  price: bigint
  royalties: smallint

  """ACTIVE: 0\nFINISHED: 1\nCANCELED: 2"""
  status: smallint
  timestamp: timestamptz
  token_id: bigint
}

"""
order by max() on columns of table "swap"
"""
input swap_max_order_by {
  amount: order_by
  amount_left: order_by
  contract_address: order_by
  contract_version: order_by
  creator_id: order_by
  fa2_id: order_by
  id: order_by
  level: order_by
  ophash: order_by
  opid: order_by
  price: order_by
  royalties: order_by

  """ACTIVE: 0\nFINISHED: 1\nCANCELED: 2"""
  status: order_by
  timestamp: order_by
  token_id: order_by
}

"""aggregate min on columns"""
type swap_min_fields {
  amount: smallint
  amount_left: smallint
  contract_address: String
  contract_version: smallint
  creator_id: String
  fa2_id: String
  id: bigint
  level: bigint
  ophash: String
  opid: bigint
  price: bigint
  royalties: smallint

  """ACTIVE: 0\nFINISHED: 1\nCANCELED: 2"""
  status: smallint
  timestamp: timestamptz
  token_id: bigint
}

"""
order by min() on columns of table "swap"
"""
input swap_min_order_by {
  amount: order_by
  amount_left: order_by
  contract_address: order_by
  contract_version: order_by
  creator_id: order_by
  fa2_id: order_by
  id: order_by
  level: order_by
  ophash: order_by
  opid: order_by
  price: order_by
  royalties: order_by

  """ACTIVE: 0\nFINISHED: 1\nCANCELED: 2"""
  status: order_by
  timestamp: order_by
  token_id: order_by
}

"""Ordering options when selecting data from "swap"."""
input swap_order_by {
  amount: order_by
  amount_left: order_by
  contract_address: order_by
  contract_version: order_by
  creator: holder_order_by
  creator_id: order_by
  fa2: fa2_order_by
  fa2_id: order_by
  id: order_by
  is_valid: order_by
  level: order_by
  ophash: order_by
  opid: order_by
  price: order_by
  royalties: order_by
  status: order_by
  timestamp: order_by
  token: token_order_by
  token_id: order_by
  trades_aggregate: trade_aggregate_order_by
}

"""
select columns of table "swap"
"""
enum swap_select_column {
  """column name"""
  amount

  """column name"""
  amount_left

  """column name"""
  contract_address

  """column name"""
  contract_version

  """column name"""
  creator_id

  """column name"""
  fa2_id

  """column name"""
  id

  """column name"""
  is_valid

  """column name"""
  level

  """column name"""
  ophash

  """column name"""
  opid

  """column name"""
  price

  """column name"""
  royalties

  """column name"""
  status

  """column name"""
  timestamp

  """column name"""
  token_id
}

"""aggregate stddev on columns"""
type swap_stddev_fields {
  amount: Float
  amount_left: Float
  contract_version: Float
  id: Float
  level: Float
  opid: Float
  price: Float
  royalties: Float

  """ACTIVE: 0\nFINISHED: 1\nCANCELED: 2"""
  status: Float
  token_id: Float
}

"""
order by stddev() on columns of table "swap"
"""
input swap_stddev_order_by {
  amount: order_by
  amount_left: order_by
  contract_version: order_by
  id: order_by
  level: order_by
  opid: order_by
  price: order_by
  royalties: order_by

  """ACTIVE: 0\nFINISHED: 1\nCANCELED: 2"""
  status: order_by
  token_id: order_by
}

"""aggregate stddev_pop on columns"""
type swap_stddev_pop_fields {
  amount: Float
  amount_left: Float
  contract_version: Float
  id: Float
  level: Float
  opid: Float
  price: Float
  royalties: Float

  """ACTIVE: 0\nFINISHED: 1\nCANCELED: 2"""
  status: Float
  token_id: Float
}

"""
order by stddev_pop() on columns of table "swap"
"""
input swap_stddev_pop_order_by {
  amount: order_by
  amount_left: order_by
  contract_version: order_by
  id: order_by
  level: order_by
  opid: order_by
  price: order_by
  royalties: order_by

  """ACTIVE: 0\nFINISHED: 1\nCANCELED: 2"""
  status: order_by
  token_id: order_by
}

"""aggregate stddev_samp on columns"""
type swap_stddev_samp_fields {
  amount: Float
  amount_left: Float
  contract_version: Float
  id: Float
  level: Float
  opid: Float
  price: Float
  royalties: Float

  """ACTIVE: 0\nFINISHED: 1\nCANCELED: 2"""
  status: Float
  token_id: Float
}

"""
order by stddev_samp() on columns of table "swap"
"""
input swap_stddev_samp_order_by {
  amount: order_by
  amount_left: order_by
  contract_version: order_by
  id: order_by
  level: order_by
  opid: order_by
  price: order_by
  royalties: order_by

  """ACTIVE: 0\nFINISHED: 1\nCANCELED: 2"""
  status: order_by
  token_id: order_by
}

"""aggregate sum on columns"""
type swap_sum_fields {
  amount: smallint
  amount_left: smallint
  contract_version: smallint
  id: bigint
  level: bigint
  opid: bigint
  price: bigint
  royalties: smallint

  """ACTIVE: 0\nFINISHED: 1\nCANCELED: 2"""
  status: smallint
  token_id: bigint
}

"""
order by sum() on columns of table "swap"
"""
input swap_sum_order_by {
  amount: order_by
  amount_left: order_by
  contract_version: order_by
  id: order_by
  level: order_by
  opid: order_by
  price: order_by
  royalties: order_by

  """ACTIVE: 0\nFINISHED: 1\nCANCELED: 2"""
  status: order_by
  token_id: order_by
}

"""aggregate var_pop on columns"""
type swap_var_pop_fields {
  amount: Float
  amount_left: Float
  contract_version: Float
  id: Float
  level: Float
  opid: Float
  price: Float
  royalties: Float

  """ACTIVE: 0\nFINISHED: 1\nCANCELED: 2"""
  status: Float
  token_id: Float
}

"""
order by var_pop() on columns of table "swap"
"""
input swap_var_pop_order_by {
  amount: order_by
  amount_left: order_by
  contract_version: order_by
  id: order_by
  level: order_by
  opid: order_by
  price: order_by
  royalties: order_by

  """ACTIVE: 0\nFINISHED: 1\nCANCELED: 2"""
  status: order_by
  token_id: order_by
}

"""aggregate var_samp on columns"""
type swap_var_samp_fields {
  amount: Float
  amount_left: Float
  contract_version: Float
  id: Float
  level: Float
  opid: Float
  price: Float
  royalties: Float

  """ACTIVE: 0\nFINISHED: 1\nCANCELED: 2"""
  status: Float
  token_id: Float
}

"""
order by var_samp() on columns of table "swap"
"""
input swap_var_samp_order_by {
  amount: order_by
  amount_left: order_by
  contract_version: order_by
  id: order_by
  level: order_by
  opid: order_by
  price: order_by
  royalties: order_by

  """ACTIVE: 0\nFINISHED: 1\nCANCELED: 2"""
  status: order_by
  token_id: order_by
}

"""aggregate variance on columns"""
type swap_variance_fields {
  amount: Float
  amount_left: Float
  contract_version: Float
  id: Float
  level: Float
  opid: Float
  price: Float
  royalties: Float

  """ACTIVE: 0\nFINISHED: 1\nCANCELED: 2"""
  status: Float
  token_id: Float
}

"""
order by variance() on columns of table "swap"
"""
input swap_variance_order_by {
  amount: order_by
  amount_left: order_by
  contract_version: order_by
  id: order_by
  level: order_by
  opid: order_by
  price: order_by
  royalties: order_by

  """ACTIVE: 0\nFINISHED: 1\nCANCELED: 2"""
  status: order_by
  token_id: order_by
}

"""
columns and relationships of "tag_model"
"""
type tag_model {
  id: bigint!
  tag: String!

  """An array relationship"""
  tag_tokens(
    """distinct select on columns"""
    distinct_on: [token_tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_tag_order_by!]

    """filter the rows returned"""
    where: token_tag_bool_exp
  ): [token_tag!]!

  """An aggregate relationship"""
  tag_tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [token_tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_tag_order_by!]

    """filter the rows returned"""
    where: token_tag_bool_exp
  ): token_tag_aggregate!
}

"""
aggregated selection of "tag_model"
"""
type tag_model_aggregate {
  aggregate: tag_model_aggregate_fields
  nodes: [tag_model!]!
}

"""
aggregate fields of "tag_model"
"""
type tag_model_aggregate_fields {
  avg: tag_model_avg_fields
  count(columns: [tag_model_select_column!], distinct: Boolean): Int!
  max: tag_model_max_fields
  min: tag_model_min_fields
  stddev: tag_model_stddev_fields
  stddev_pop: tag_model_stddev_pop_fields
  stddev_samp: tag_model_stddev_samp_fields
  sum: tag_model_sum_fields
  var_pop: tag_model_var_pop_fields
  var_samp: tag_model_var_samp_fields
  variance: tag_model_variance_fields
}

"""aggregate avg on columns"""
type tag_model_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "tag_model". All fields are combined with a logical 'AND'.
"""
input tag_model_bool_exp {
  _and: [tag_model_bool_exp!]
  _not: tag_model_bool_exp
  _or: [tag_model_bool_exp!]
  id: bigint_comparison_exp
  tag: String_comparison_exp
  tag_tokens: token_tag_bool_exp
}

"""aggregate max on columns"""
type tag_model_max_fields {
  id: bigint
  tag: String
}

"""aggregate min on columns"""
type tag_model_min_fields {
  id: bigint
  tag: String
}

"""Ordering options when selecting data from "tag_model"."""
input tag_model_order_by {
  id: order_by
  tag: order_by
  tag_tokens_aggregate: token_tag_aggregate_order_by
}

"""
select columns of table "tag_model"
"""
enum tag_model_select_column {
  """column name"""
  id

  """column name"""
  tag
}

"""aggregate stddev on columns"""
type tag_model_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type tag_model_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type tag_model_stddev_samp_fields {
  id: Float
}

"""aggregate sum on columns"""
type tag_model_sum_fields {
  id: bigint
}

"""aggregate var_pop on columns"""
type tag_model_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type tag_model_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type tag_model_variance_fields {
  id: Float
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "token"
"""
type token {
  accessibility(
    """JSON select path"""
    path: String
  ): jsonb!
  artifact_uri: String!
  attributes(
    """JSON select path"""
    path: String
  ): jsonb
  content_rating: String!

  """An object relationship"""
  creator: holder
  creator_id: String
  description: String!
  display_uri: String!
  extra(
    """JSON select path"""
    path: String
  ): jsonb!
  formats(
    """JSON select path"""
    path: String
  ): jsonb!
  hdao_balance: bigint!
  id: bigint!
  is_signed: Boolean!
  language: String!
  level: bigint!
  metadata: String!
  mime: String!

  """An array relationship"""
  operators(
    """distinct select on columns"""
    distinct_on: [token_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_operator_order_by!]

    """filter the rows returned"""
    where: token_operator_bool_exp
  ): [token_operator!]!

  """An aggregate relationship"""
  operators_aggregate(
    """distinct select on columns"""
    distinct_on: [token_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_operator_order_by!]

    """filter the rows returned"""
    where: token_operator_bool_exp
  ): token_operator_aggregate!
  right_uri: String!
  rights: String!
  royalties: smallint!
  supply: smallint!

  """An array relationship"""
  swaps(
    """distinct select on columns"""
    distinct_on: [swap_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [swap_order_by!]

    """filter the rows returned"""
    where: swap_bool_exp
  ): [swap!]!

  """An aggregate relationship"""
  swaps_aggregate(
    """distinct select on columns"""
    distinct_on: [swap_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [swap_order_by!]

    """filter the rows returned"""
    where: swap_bool_exp
  ): swap_aggregate!
  thumbnail_uri: String!
  timestamp: timestamptz!
  title: String!

  """An array relationship"""
  token_holders(
    """distinct select on columns"""
    distinct_on: [token_holder_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_holder_order_by!]

    """filter the rows returned"""
    where: token_holder_bool_exp
  ): [token_holder!]!

  """An aggregate relationship"""
  token_holders_aggregate(
    """distinct select on columns"""
    distinct_on: [token_holder_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_holder_order_by!]

    """filter the rows returned"""
    where: token_holder_bool_exp
  ): token_holder_aggregate!

  """An array relationship"""
  token_signatures(
    """distinct select on columns"""
    distinct_on: [split_signatures_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_signatures_order_by!]

    """filter the rows returned"""
    where: split_signatures_bool_exp
  ): [split_signatures!]!

  """An aggregate relationship"""
  token_signatures_aggregate(
    """distinct select on columns"""
    distinct_on: [split_signatures_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_signatures_order_by!]

    """filter the rows returned"""
    where: split_signatures_bool_exp
  ): split_signatures_aggregate!

  """An array relationship"""
  token_tags(
    """distinct select on columns"""
    distinct_on: [token_tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_tag_order_by!]

    """filter the rows returned"""
    where: token_tag_bool_exp
  ): [token_tag!]!

  """An aggregate relationship"""
  token_tags_aggregate(
    """distinct select on columns"""
    distinct_on: [token_tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_tag_order_by!]

    """filter the rows returned"""
    where: token_tag_bool_exp
  ): token_tag_aggregate!

  """An array relationship"""
  trades(
    """distinct select on columns"""
    distinct_on: [trade_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trade_order_by!]

    """filter the rows returned"""
    where: trade_bool_exp
  ): [trade!]!

  """An aggregate relationship"""
  trades_aggregate(
    """distinct select on columns"""
    distinct_on: [trade_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trade_order_by!]

    """filter the rows returned"""
    where: trade_bool_exp
  ): trade_aggregate!
}

"""
aggregated selection of "token"
"""
type token_aggregate {
  aggregate: token_aggregate_fields
  nodes: [token!]!
}

"""
aggregate fields of "token"
"""
type token_aggregate_fields {
  avg: token_avg_fields
  count(columns: [token_select_column!], distinct: Boolean): Int!
  max: token_max_fields
  min: token_min_fields
  stddev: token_stddev_fields
  stddev_pop: token_stddev_pop_fields
  stddev_samp: token_stddev_samp_fields
  sum: token_sum_fields
  var_pop: token_var_pop_fields
  var_samp: token_var_samp_fields
  variance: token_variance_fields
}

"""
order by aggregate values of table "token"
"""
input token_aggregate_order_by {
  avg: token_avg_order_by
  count: order_by
  max: token_max_order_by
  min: token_min_order_by
  stddev: token_stddev_order_by
  stddev_pop: token_stddev_pop_order_by
  stddev_samp: token_stddev_samp_order_by
  sum: token_sum_order_by
  var_pop: token_var_pop_order_by
  var_samp: token_var_samp_order_by
  variance: token_variance_order_by
}

"""aggregate avg on columns"""
type token_avg_fields {
  hdao_balance: Float
  id: Float
  level: Float
  royalties: Float
  supply: Float
}

"""
order by avg() on columns of table "token"
"""
input token_avg_order_by {
  hdao_balance: order_by
  id: order_by
  level: order_by
  royalties: order_by
  supply: order_by
}

"""
Boolean expression to filter rows from the table "token". All fields are combined with a logical 'AND'.
"""
input token_bool_exp {
  _and: [token_bool_exp!]
  _not: token_bool_exp
  _or: [token_bool_exp!]
  accessibility: jsonb_comparison_exp
  artifact_uri: String_comparison_exp
  attributes: jsonb_comparison_exp
  content_rating: String_comparison_exp
  creator: holder_bool_exp
  creator_id: String_comparison_exp
  description: String_comparison_exp
  display_uri: String_comparison_exp
  extra: jsonb_comparison_exp
  formats: jsonb_comparison_exp
  hdao_balance: bigint_comparison_exp
  id: bigint_comparison_exp
  is_signed: Boolean_comparison_exp
  language: String_comparison_exp
  level: bigint_comparison_exp
  metadata: String_comparison_exp
  mime: String_comparison_exp
  operators: token_operator_bool_exp
  right_uri: String_comparison_exp
  rights: String_comparison_exp
  royalties: smallint_comparison_exp
  supply: smallint_comparison_exp
  swaps: swap_bool_exp
  thumbnail_uri: String_comparison_exp
  timestamp: timestamptz_comparison_exp
  title: String_comparison_exp
  token_holders: token_holder_bool_exp
  token_signatures: split_signatures_bool_exp
  token_tags: token_tag_bool_exp
  trades: trade_bool_exp
}

"""
columns and relationships of "token_holder"
"""
type token_holder {
  """An object relationship"""
  holder: holder!
  holder_id: String!
  id: Int!
  quantity: bigint!

  """An object relationship"""
  token: token!
  token_id: bigint!
}

"""
aggregated selection of "token_holder"
"""
type token_holder_aggregate {
  aggregate: token_holder_aggregate_fields
  nodes: [token_holder!]!
}

"""
aggregate fields of "token_holder"
"""
type token_holder_aggregate_fields {
  avg: token_holder_avg_fields
  count(columns: [token_holder_select_column!], distinct: Boolean): Int!
  max: token_holder_max_fields
  min: token_holder_min_fields
  stddev: token_holder_stddev_fields
  stddev_pop: token_holder_stddev_pop_fields
  stddev_samp: token_holder_stddev_samp_fields
  sum: token_holder_sum_fields
  var_pop: token_holder_var_pop_fields
  var_samp: token_holder_var_samp_fields
  variance: token_holder_variance_fields
}

"""
order by aggregate values of table "token_holder"
"""
input token_holder_aggregate_order_by {
  avg: token_holder_avg_order_by
  count: order_by
  max: token_holder_max_order_by
  min: token_holder_min_order_by
  stddev: token_holder_stddev_order_by
  stddev_pop: token_holder_stddev_pop_order_by
  stddev_samp: token_holder_stddev_samp_order_by
  sum: token_holder_sum_order_by
  var_pop: token_holder_var_pop_order_by
  var_samp: token_holder_var_samp_order_by
  variance: token_holder_variance_order_by
}

"""aggregate avg on columns"""
type token_holder_avg_fields {
  id: Float
  quantity: Float
  token_id: Float
}

"""
order by avg() on columns of table "token_holder"
"""
input token_holder_avg_order_by {
  id: order_by
  quantity: order_by
  token_id: order_by
}

"""
Boolean expression to filter rows from the table "token_holder". All fields are combined with a logical 'AND'.
"""
input token_holder_bool_exp {
  _and: [token_holder_bool_exp!]
  _not: token_holder_bool_exp
  _or: [token_holder_bool_exp!]
  holder: holder_bool_exp
  holder_id: String_comparison_exp
  id: Int_comparison_exp
  quantity: bigint_comparison_exp
  token: token_bool_exp
  token_id: bigint_comparison_exp
}

"""aggregate max on columns"""
type token_holder_max_fields {
  holder_id: String
  id: Int
  quantity: bigint
  token_id: bigint
}

"""
order by max() on columns of table "token_holder"
"""
input token_holder_max_order_by {
  holder_id: order_by
  id: order_by
  quantity: order_by
  token_id: order_by
}

"""aggregate min on columns"""
type token_holder_min_fields {
  holder_id: String
  id: Int
  quantity: bigint
  token_id: bigint
}

"""
order by min() on columns of table "token_holder"
"""
input token_holder_min_order_by {
  holder_id: order_by
  id: order_by
  quantity: order_by
  token_id: order_by
}

"""Ordering options when selecting data from "token_holder"."""
input token_holder_order_by {
  holder: holder_order_by
  holder_id: order_by
  id: order_by
  quantity: order_by
  token: token_order_by
  token_id: order_by
}

"""
select columns of table "token_holder"
"""
enum token_holder_select_column {
  """column name"""
  holder_id

  """column name"""
  id

  """column name"""
  quantity

  """column name"""
  token_id
}

"""aggregate stddev on columns"""
type token_holder_stddev_fields {
  id: Float
  quantity: Float
  token_id: Float
}

"""
order by stddev() on columns of table "token_holder"
"""
input token_holder_stddev_order_by {
  id: order_by
  quantity: order_by
  token_id: order_by
}

"""aggregate stddev_pop on columns"""
type token_holder_stddev_pop_fields {
  id: Float
  quantity: Float
  token_id: Float
}

"""
order by stddev_pop() on columns of table "token_holder"
"""
input token_holder_stddev_pop_order_by {
  id: order_by
  quantity: order_by
  token_id: order_by
}

"""aggregate stddev_samp on columns"""
type token_holder_stddev_samp_fields {
  id: Float
  quantity: Float
  token_id: Float
}

"""
order by stddev_samp() on columns of table "token_holder"
"""
input token_holder_stddev_samp_order_by {
  id: order_by
  quantity: order_by
  token_id: order_by
}

"""aggregate sum on columns"""
type token_holder_sum_fields {
  id: Int
  quantity: bigint
  token_id: bigint
}

"""
order by sum() on columns of table "token_holder"
"""
input token_holder_sum_order_by {
  id: order_by
  quantity: order_by
  token_id: order_by
}

"""aggregate var_pop on columns"""
type token_holder_var_pop_fields {
  id: Float
  quantity: Float
  token_id: Float
}

"""
order by var_pop() on columns of table "token_holder"
"""
input token_holder_var_pop_order_by {
  id: order_by
  quantity: order_by
  token_id: order_by
}

"""aggregate var_samp on columns"""
type token_holder_var_samp_fields {
  id: Float
  quantity: Float
  token_id: Float
}

"""
order by var_samp() on columns of table "token_holder"
"""
input token_holder_var_samp_order_by {
  id: order_by
  quantity: order_by
  token_id: order_by
}

"""aggregate variance on columns"""
type token_holder_variance_fields {
  id: Float
  quantity: Float
  token_id: Float
}

"""
order by variance() on columns of table "token_holder"
"""
input token_holder_variance_order_by {
  id: order_by
  quantity: order_by
  token_id: order_by
}

"""aggregate max on columns"""
type token_max_fields {
  artifact_uri: String
  content_rating: String
  creator_id: String
  description: String
  display_uri: String
  hdao_balance: bigint
  id: bigint
  language: String
  level: bigint
  metadata: String
  mime: String
  right_uri: String
  rights: String
  royalties: smallint
  supply: smallint
  thumbnail_uri: String
  timestamp: timestamptz
  title: String
}

"""
order by max() on columns of table "token"
"""
input token_max_order_by {
  artifact_uri: order_by
  content_rating: order_by
  creator_id: order_by
  description: order_by
  display_uri: order_by
  hdao_balance: order_by
  id: order_by
  language: order_by
  level: order_by
  metadata: order_by
  mime: order_by
  right_uri: order_by
  rights: order_by
  royalties: order_by
  supply: order_by
  thumbnail_uri: order_by
  timestamp: order_by
  title: order_by
}

"""aggregate min on columns"""
type token_min_fields {
  artifact_uri: String
  content_rating: String
  creator_id: String
  description: String
  display_uri: String
  hdao_balance: bigint
  id: bigint
  language: String
  level: bigint
  metadata: String
  mime: String
  right_uri: String
  rights: String
  royalties: smallint
  supply: smallint
  thumbnail_uri: String
  timestamp: timestamptz
  title: String
}

"""
order by min() on columns of table "token"
"""
input token_min_order_by {
  artifact_uri: order_by
  content_rating: order_by
  creator_id: order_by
  description: order_by
  display_uri: order_by
  hdao_balance: order_by
  id: order_by
  language: order_by
  level: order_by
  metadata: order_by
  mime: order_by
  right_uri: order_by
  rights: order_by
  royalties: order_by
  supply: order_by
  thumbnail_uri: order_by
  timestamp: order_by
  title: order_by
}

"""
columns and relationships of "token_operator"
"""
type token_operator {
  id: Int!
  level: bigint!
  operator: String!

  """An object relationship"""
  owner: holder!
  owner_id: String!

  """An object relationship"""
  token: token!
  token_id: bigint!
}

"""
aggregated selection of "token_operator"
"""
type token_operator_aggregate {
  aggregate: token_operator_aggregate_fields
  nodes: [token_operator!]!
}

"""
aggregate fields of "token_operator"
"""
type token_operator_aggregate_fields {
  avg: token_operator_avg_fields
  count(columns: [token_operator_select_column!], distinct: Boolean): Int!
  max: token_operator_max_fields
  min: token_operator_min_fields
  stddev: token_operator_stddev_fields
  stddev_pop: token_operator_stddev_pop_fields
  stddev_samp: token_operator_stddev_samp_fields
  sum: token_operator_sum_fields
  var_pop: token_operator_var_pop_fields
  var_samp: token_operator_var_samp_fields
  variance: token_operator_variance_fields
}

"""
order by aggregate values of table "token_operator"
"""
input token_operator_aggregate_order_by {
  avg: token_operator_avg_order_by
  count: order_by
  max: token_operator_max_order_by
  min: token_operator_min_order_by
  stddev: token_operator_stddev_order_by
  stddev_pop: token_operator_stddev_pop_order_by
  stddev_samp: token_operator_stddev_samp_order_by
  sum: token_operator_sum_order_by
  var_pop: token_operator_var_pop_order_by
  var_samp: token_operator_var_samp_order_by
  variance: token_operator_variance_order_by
}

"""aggregate avg on columns"""
type token_operator_avg_fields {
  id: Float
  level: Float
  token_id: Float
}

"""
order by avg() on columns of table "token_operator"
"""
input token_operator_avg_order_by {
  id: order_by
  level: order_by
  token_id: order_by
}

"""
Boolean expression to filter rows from the table "token_operator". All fields are combined with a logical 'AND'.
"""
input token_operator_bool_exp {
  _and: [token_operator_bool_exp!]
  _not: token_operator_bool_exp
  _or: [token_operator_bool_exp!]
  id: Int_comparison_exp
  level: bigint_comparison_exp
  operator: String_comparison_exp
  owner: holder_bool_exp
  owner_id: String_comparison_exp
  token: token_bool_exp
  token_id: bigint_comparison_exp
}

"""aggregate max on columns"""
type token_operator_max_fields {
  id: Int
  level: bigint
  operator: String
  owner_id: String
  token_id: bigint
}

"""
order by max() on columns of table "token_operator"
"""
input token_operator_max_order_by {
  id: order_by
  level: order_by
  operator: order_by
  owner_id: order_by
  token_id: order_by
}

"""aggregate min on columns"""
type token_operator_min_fields {
  id: Int
  level: bigint
  operator: String
  owner_id: String
  token_id: bigint
}

"""
order by min() on columns of table "token_operator"
"""
input token_operator_min_order_by {
  id: order_by
  level: order_by
  operator: order_by
  owner_id: order_by
  token_id: order_by
}

"""Ordering options when selecting data from "token_operator"."""
input token_operator_order_by {
  id: order_by
  level: order_by
  operator: order_by
  owner: holder_order_by
  owner_id: order_by
  token: token_order_by
  token_id: order_by
}

"""
select columns of table "token_operator"
"""
enum token_operator_select_column {
  """column name"""
  id

  """column name"""
  level

  """column name"""
  operator

  """column name"""
  owner_id

  """column name"""
  token_id
}

"""aggregate stddev on columns"""
type token_operator_stddev_fields {
  id: Float
  level: Float
  token_id: Float
}

"""
order by stddev() on columns of table "token_operator"
"""
input token_operator_stddev_order_by {
  id: order_by
  level: order_by
  token_id: order_by
}

"""aggregate stddev_pop on columns"""
type token_operator_stddev_pop_fields {
  id: Float
  level: Float
  token_id: Float
}

"""
order by stddev_pop() on columns of table "token_operator"
"""
input token_operator_stddev_pop_order_by {
  id: order_by
  level: order_by
  token_id: order_by
}

"""aggregate stddev_samp on columns"""
type token_operator_stddev_samp_fields {
  id: Float
  level: Float
  token_id: Float
}

"""
order by stddev_samp() on columns of table "token_operator"
"""
input token_operator_stddev_samp_order_by {
  id: order_by
  level: order_by
  token_id: order_by
}

"""aggregate sum on columns"""
type token_operator_sum_fields {
  id: Int
  level: bigint
  token_id: bigint
}

"""
order by sum() on columns of table "token_operator"
"""
input token_operator_sum_order_by {
  id: order_by
  level: order_by
  token_id: order_by
}

"""aggregate var_pop on columns"""
type token_operator_var_pop_fields {
  id: Float
  level: Float
  token_id: Float
}

"""
order by var_pop() on columns of table "token_operator"
"""
input token_operator_var_pop_order_by {
  id: order_by
  level: order_by
  token_id: order_by
}

"""aggregate var_samp on columns"""
type token_operator_var_samp_fields {
  id: Float
  level: Float
  token_id: Float
}

"""
order by var_samp() on columns of table "token_operator"
"""
input token_operator_var_samp_order_by {
  id: order_by
  level: order_by
  token_id: order_by
}

"""aggregate variance on columns"""
type token_operator_variance_fields {
  id: Float
  level: Float
  token_id: Float
}

"""
order by variance() on columns of table "token_operator"
"""
input token_operator_variance_order_by {
  id: order_by
  level: order_by
  token_id: order_by
}

"""Ordering options when selecting data from "token"."""
input token_order_by {
  accessibility: order_by
  artifact_uri: order_by
  attributes: order_by
  content_rating: order_by
  creator: holder_order_by
  creator_id: order_by
  description: order_by
  display_uri: order_by
  extra: order_by
  formats: order_by
  hdao_balance: order_by
  id: order_by
  is_signed: order_by
  language: order_by
  level: order_by
  metadata: order_by
  mime: order_by
  operators_aggregate: token_operator_aggregate_order_by
  right_uri: order_by
  rights: order_by
  royalties: order_by
  supply: order_by
  swaps_aggregate: swap_aggregate_order_by
  thumbnail_uri: order_by
  timestamp: order_by
  title: order_by
  token_holders_aggregate: token_holder_aggregate_order_by
  token_signatures_aggregate: split_signatures_aggregate_order_by
  token_tags_aggregate: token_tag_aggregate_order_by
  trades_aggregate: trade_aggregate_order_by
}

"""
select columns of table "token"
"""
enum token_select_column {
  """column name"""
  accessibility

  """column name"""
  artifact_uri

  """column name"""
  attributes

  """column name"""
  content_rating

  """column name"""
  creator_id

  """column name"""
  description

  """column name"""
  display_uri

  """column name"""
  extra

  """column name"""
  formats

  """column name"""
  hdao_balance

  """column name"""
  id

  """column name"""
  is_signed

  """column name"""
  language

  """column name"""
  level

  """column name"""
  metadata

  """column name"""
  mime

  """column name"""
  right_uri

  """column name"""
  rights

  """column name"""
  royalties

  """column name"""
  supply

  """column name"""
  thumbnail_uri

  """column name"""
  timestamp

  """column name"""
  title
}

"""aggregate stddev on columns"""
type token_stddev_fields {
  hdao_balance: Float
  id: Float
  level: Float
  royalties: Float
  supply: Float
}

"""
order by stddev() on columns of table "token"
"""
input token_stddev_order_by {
  hdao_balance: order_by
  id: order_by
  level: order_by
  royalties: order_by
  supply: order_by
}

"""aggregate stddev_pop on columns"""
type token_stddev_pop_fields {
  hdao_balance: Float
  id: Float
  level: Float
  royalties: Float
  supply: Float
}

"""
order by stddev_pop() on columns of table "token"
"""
input token_stddev_pop_order_by {
  hdao_balance: order_by
  id: order_by
  level: order_by
  royalties: order_by
  supply: order_by
}

"""aggregate stddev_samp on columns"""
type token_stddev_samp_fields {
  hdao_balance: Float
  id: Float
  level: Float
  royalties: Float
  supply: Float
}

"""
order by stddev_samp() on columns of table "token"
"""
input token_stddev_samp_order_by {
  hdao_balance: order_by
  id: order_by
  level: order_by
  royalties: order_by
  supply: order_by
}

"""aggregate sum on columns"""
type token_sum_fields {
  hdao_balance: bigint
  id: bigint
  level: bigint
  royalties: smallint
  supply: smallint
}

"""
order by sum() on columns of table "token"
"""
input token_sum_order_by {
  hdao_balance: order_by
  id: order_by
  level: order_by
  royalties: order_by
  supply: order_by
}

"""
columns and relationships of "token_tag"
"""
type token_tag {
  id: Int!

  """An object relationship"""
  tag: tag_model!
  tag_id: bigint!

  """An object relationship"""
  token: token!
  token_id: bigint!
}

"""
aggregated selection of "token_tag"
"""
type token_tag_aggregate {
  aggregate: token_tag_aggregate_fields
  nodes: [token_tag!]!
}

"""
aggregate fields of "token_tag"
"""
type token_tag_aggregate_fields {
  avg: token_tag_avg_fields
  count(columns: [token_tag_select_column!], distinct: Boolean): Int!
  max: token_tag_max_fields
  min: token_tag_min_fields
  stddev: token_tag_stddev_fields
  stddev_pop: token_tag_stddev_pop_fields
  stddev_samp: token_tag_stddev_samp_fields
  sum: token_tag_sum_fields
  var_pop: token_tag_var_pop_fields
  var_samp: token_tag_var_samp_fields
  variance: token_tag_variance_fields
}

"""
order by aggregate values of table "token_tag"
"""
input token_tag_aggregate_order_by {
  avg: token_tag_avg_order_by
  count: order_by
  max: token_tag_max_order_by
  min: token_tag_min_order_by
  stddev: token_tag_stddev_order_by
  stddev_pop: token_tag_stddev_pop_order_by
  stddev_samp: token_tag_stddev_samp_order_by
  sum: token_tag_sum_order_by
  var_pop: token_tag_var_pop_order_by
  var_samp: token_tag_var_samp_order_by
  variance: token_tag_variance_order_by
}

"""aggregate avg on columns"""
type token_tag_avg_fields {
  id: Float
  tag_id: Float
  token_id: Float
}

"""
order by avg() on columns of table "token_tag"
"""
input token_tag_avg_order_by {
  id: order_by
  tag_id: order_by
  token_id: order_by
}

"""
Boolean expression to filter rows from the table "token_tag". All fields are combined with a logical 'AND'.
"""
input token_tag_bool_exp {
  _and: [token_tag_bool_exp!]
  _not: token_tag_bool_exp
  _or: [token_tag_bool_exp!]
  id: Int_comparison_exp
  tag: tag_model_bool_exp
  tag_id: bigint_comparison_exp
  token: token_bool_exp
  token_id: bigint_comparison_exp
}

"""aggregate max on columns"""
type token_tag_max_fields {
  id: Int
  tag_id: bigint
  token_id: bigint
}

"""
order by max() on columns of table "token_tag"
"""
input token_tag_max_order_by {
  id: order_by
  tag_id: order_by
  token_id: order_by
}

"""aggregate min on columns"""
type token_tag_min_fields {
  id: Int
  tag_id: bigint
  token_id: bigint
}

"""
order by min() on columns of table "token_tag"
"""
input token_tag_min_order_by {
  id: order_by
  tag_id: order_by
  token_id: order_by
}

"""Ordering options when selecting data from "token_tag"."""
input token_tag_order_by {
  id: order_by
  tag: tag_model_order_by
  tag_id: order_by
  token: token_order_by
  token_id: order_by
}

"""
select columns of table "token_tag"
"""
enum token_tag_select_column {
  """column name"""
  id

  """column name"""
  tag_id

  """column name"""
  token_id
}

"""aggregate stddev on columns"""
type token_tag_stddev_fields {
  id: Float
  tag_id: Float
  token_id: Float
}

"""
order by stddev() on columns of table "token_tag"
"""
input token_tag_stddev_order_by {
  id: order_by
  tag_id: order_by
  token_id: order_by
}

"""aggregate stddev_pop on columns"""
type token_tag_stddev_pop_fields {
  id: Float
  tag_id: Float
  token_id: Float
}

"""
order by stddev_pop() on columns of table "token_tag"
"""
input token_tag_stddev_pop_order_by {
  id: order_by
  tag_id: order_by
  token_id: order_by
}

"""aggregate stddev_samp on columns"""
type token_tag_stddev_samp_fields {
  id: Float
  tag_id: Float
  token_id: Float
}

"""
order by stddev_samp() on columns of table "token_tag"
"""
input token_tag_stddev_samp_order_by {
  id: order_by
  tag_id: order_by
  token_id: order_by
}

"""aggregate sum on columns"""
type token_tag_sum_fields {
  id: Int
  tag_id: bigint
  token_id: bigint
}

"""
order by sum() on columns of table "token_tag"
"""
input token_tag_sum_order_by {
  id: order_by
  tag_id: order_by
  token_id: order_by
}

"""aggregate var_pop on columns"""
type token_tag_var_pop_fields {
  id: Float
  tag_id: Float
  token_id: Float
}

"""
order by var_pop() on columns of table "token_tag"
"""
input token_tag_var_pop_order_by {
  id: order_by
  tag_id: order_by
  token_id: order_by
}

"""aggregate var_samp on columns"""
type token_tag_var_samp_fields {
  id: Float
  tag_id: Float
  token_id: Float
}

"""
order by var_samp() on columns of table "token_tag"
"""
input token_tag_var_samp_order_by {
  id: order_by
  tag_id: order_by
  token_id: order_by
}

"""aggregate variance on columns"""
type token_tag_variance_fields {
  id: Float
  tag_id: Float
  token_id: Float
}

"""
order by variance() on columns of table "token_tag"
"""
input token_tag_variance_order_by {
  id: order_by
  tag_id: order_by
  token_id: order_by
}

"""aggregate var_pop on columns"""
type token_var_pop_fields {
  hdao_balance: Float
  id: Float
  level: Float
  royalties: Float
  supply: Float
}

"""
order by var_pop() on columns of table "token"
"""
input token_var_pop_order_by {
  hdao_balance: order_by
  id: order_by
  level: order_by
  royalties: order_by
  supply: order_by
}

"""aggregate var_samp on columns"""
type token_var_samp_fields {
  hdao_balance: Float
  id: Float
  level: Float
  royalties: Float
  supply: Float
}

"""
order by var_samp() on columns of table "token"
"""
input token_var_samp_order_by {
  hdao_balance: order_by
  id: order_by
  level: order_by
  royalties: order_by
  supply: order_by
}

"""aggregate variance on columns"""
type token_variance_fields {
  hdao_balance: Float
  id: Float
  level: Float
  royalties: Float
  supply: Float
}

"""
order by variance() on columns of table "token"
"""
input token_variance_order_by {
  hdao_balance: order_by
  id: order_by
  level: order_by
  royalties: order_by
  supply: order_by
}

"""
columns and relationships of "trade"
"""
type trade {
  amount: bigint!

  """An object relationship"""
  buyer: holder!
  buyer_id: String!
  id: bigint!
  level: bigint!
  ophash: String!

  """An object relationship"""
  seller: holder!
  seller_id: String!

  """An object relationship"""
  swap: swap!
  swap_id: bigint!
  timestamp: timestamptz!

  """An object relationship"""
  token: token!
  token_id: bigint!
}

"""
aggregated selection of "trade"
"""
type trade_aggregate {
  aggregate: trade_aggregate_fields
  nodes: [trade!]!
}

"""
aggregate fields of "trade"
"""
type trade_aggregate_fields {
  avg: trade_avg_fields
  count(columns: [trade_select_column!], distinct: Boolean): Int!
  max: trade_max_fields
  min: trade_min_fields
  stddev: trade_stddev_fields
  stddev_pop: trade_stddev_pop_fields
  stddev_samp: trade_stddev_samp_fields
  sum: trade_sum_fields
  var_pop: trade_var_pop_fields
  var_samp: trade_var_samp_fields
  variance: trade_variance_fields
}

"""
order by aggregate values of table "trade"
"""
input trade_aggregate_order_by {
  avg: trade_avg_order_by
  count: order_by
  max: trade_max_order_by
  min: trade_min_order_by
  stddev: trade_stddev_order_by
  stddev_pop: trade_stddev_pop_order_by
  stddev_samp: trade_stddev_samp_order_by
  sum: trade_sum_order_by
  var_pop: trade_var_pop_order_by
  var_samp: trade_var_samp_order_by
  variance: trade_variance_order_by
}

"""aggregate avg on columns"""
type trade_avg_fields {
  amount: Float
  id: Float
  level: Float
  swap_id: Float
  token_id: Float
}

"""
order by avg() on columns of table "trade"
"""
input trade_avg_order_by {
  amount: order_by
  id: order_by
  level: order_by
  swap_id: order_by
  token_id: order_by
}

"""
Boolean expression to filter rows from the table "trade". All fields are combined with a logical 'AND'.
"""
input trade_bool_exp {
  _and: [trade_bool_exp!]
  _not: trade_bool_exp
  _or: [trade_bool_exp!]
  amount: bigint_comparison_exp
  buyer: holder_bool_exp
  buyer_id: String_comparison_exp
  id: bigint_comparison_exp
  level: bigint_comparison_exp
  ophash: String_comparison_exp
  seller: holder_bool_exp
  seller_id: String_comparison_exp
  swap: swap_bool_exp
  swap_id: bigint_comparison_exp
  timestamp: timestamptz_comparison_exp
  token: token_bool_exp
  token_id: bigint_comparison_exp
}

"""aggregate max on columns"""
type trade_max_fields {
  amount: bigint
  buyer_id: String
  id: bigint
  level: bigint
  ophash: String
  seller_id: String
  swap_id: bigint
  timestamp: timestamptz
  token_id: bigint
}

"""
order by max() on columns of table "trade"
"""
input trade_max_order_by {
  amount: order_by
  buyer_id: order_by
  id: order_by
  level: order_by
  ophash: order_by
  seller_id: order_by
  swap_id: order_by
  timestamp: order_by
  token_id: order_by
}

"""aggregate min on columns"""
type trade_min_fields {
  amount: bigint
  buyer_id: String
  id: bigint
  level: bigint
  ophash: String
  seller_id: String
  swap_id: bigint
  timestamp: timestamptz
  token_id: bigint
}

"""
order by min() on columns of table "trade"
"""
input trade_min_order_by {
  amount: order_by
  buyer_id: order_by
  id: order_by
  level: order_by
  ophash: order_by
  seller_id: order_by
  swap_id: order_by
  timestamp: order_by
  token_id: order_by
}

"""Ordering options when selecting data from "trade"."""
input trade_order_by {
  amount: order_by
  buyer: holder_order_by
  buyer_id: order_by
  id: order_by
  level: order_by
  ophash: order_by
  seller: holder_order_by
  seller_id: order_by
  swap: swap_order_by
  swap_id: order_by
  timestamp: order_by
  token: token_order_by
  token_id: order_by
}

"""
select columns of table "trade"
"""
enum trade_select_column {
  """column name"""
  amount

  """column name"""
  buyer_id

  """column name"""
  id

  """column name"""
  level

  """column name"""
  ophash

  """column name"""
  seller_id

  """column name"""
  swap_id

  """column name"""
  timestamp

  """column name"""
  token_id
}

"""aggregate stddev on columns"""
type trade_stddev_fields {
  amount: Float
  id: Float
  level: Float
  swap_id: Float
  token_id: Float
}

"""
order by stddev() on columns of table "trade"
"""
input trade_stddev_order_by {
  amount: order_by
  id: order_by
  level: order_by
  swap_id: order_by
  token_id: order_by
}

"""aggregate stddev_pop on columns"""
type trade_stddev_pop_fields {
  amount: Float
  id: Float
  level: Float
  swap_id: Float
  token_id: Float
}

"""
order by stddev_pop() on columns of table "trade"
"""
input trade_stddev_pop_order_by {
  amount: order_by
  id: order_by
  level: order_by
  swap_id: order_by
  token_id: order_by
}

"""aggregate stddev_samp on columns"""
type trade_stddev_samp_fields {
  amount: Float
  id: Float
  level: Float
  swap_id: Float
  token_id: Float
}

"""
order by stddev_samp() on columns of table "trade"
"""
input trade_stddev_samp_order_by {
  amount: order_by
  id: order_by
  level: order_by
  swap_id: order_by
  token_id: order_by
}

"""aggregate sum on columns"""
type trade_sum_fields {
  amount: bigint
  id: bigint
  level: bigint
  swap_id: bigint
  token_id: bigint
}

"""
order by sum() on columns of table "trade"
"""
input trade_sum_order_by {
  amount: order_by
  id: order_by
  level: order_by
  swap_id: order_by
  token_id: order_by
}

"""aggregate var_pop on columns"""
type trade_var_pop_fields {
  amount: Float
  id: Float
  level: Float
  swap_id: Float
  token_id: Float
}

"""
order by var_pop() on columns of table "trade"
"""
input trade_var_pop_order_by {
  amount: order_by
  id: order_by
  level: order_by
  swap_id: order_by
  token_id: order_by
}

"""aggregate var_samp on columns"""
type trade_var_samp_fields {
  amount: Float
  id: Float
  level: Float
  swap_id: Float
  token_id: Float
}

"""
order by var_samp() on columns of table "trade"
"""
input trade_var_samp_order_by {
  amount: order_by
  id: order_by
  level: order_by
  swap_id: order_by
  token_id: order_by
}

"""aggregate variance on columns"""
type trade_variance_fields {
  amount: Float
  id: Float
  level: Float
  swap_id: Float
  token_id: Float
}

"""
order by variance() on columns of table "trade"
"""
input trade_variance_order_by {
  amount: order_by
  id: order_by
  level: order_by
  swap_id: order_by
  token_id: order_by
}

